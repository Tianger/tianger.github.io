<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="3G/LTE protocol | C">
<meta property="og:type" content="website">
<meta property="og:title" content="Tianger's Family">
<meta property="og:url" content="http://tianger.github.io/page/2/index.html">
<meta property="og:site_name" content="Tianger's Family">
<meta property="og:description" content="3G/LTE protocol | C">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tianger's Family">
<meta name="twitter:description" content="3G/LTE protocol | C">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://tianger.github.io/page/2/"/>

  <title> Tianger's Family </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3000033e6d5b1f1f2b431451efbce4ef";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Tianger's Family</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Leave no regrets every day</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/19/c-and-point-sixteen-stander/" itemprop="url">
                  C与指针-第十六章-标准函数库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-19T20:51:29+08:00" content="2016-06-19">
              2016-06-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/19/c-and-point-sixteen-stander/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/19/c-and-point-sixteen-stander/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>本章主要来讲一些之前没用用过的标准函数库。分为整数函数、浮点型函数、日期和时间函数等。</p>
<h2 id="整数函数：">整数函数：</h2><p>整数函数的返回值为整型值，分为三类：算术、随机数和字符串转换。</p>
<h3 id="算术：">算术：</h3><p>标准函数库包含了4个整型算术函数—abs\labs\ div\ldiv</p>
<h4 id="abs—求绝对值:">abs—求绝对值:</h4><blockquote>
<p>原型：int abs(int value);<br>函数说明：abs用来计算传入参数的绝对值，然后将结果返回。<br>用法：<br>int answer;<br>answer = abs(-12);//answer 返回为-12的绝对值，结果为12</p>
</blockquote>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/06/19/c-and-point-sixteen-stander/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/19/c-and-point-io/" itemprop="url">
                  C与指针-第十五章--输入/输出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-19T16:20:24+08:00" content="2016-06-19">
              2016-06-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/19/c-and-point-io/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/19/c-and-point-io/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>本章主要讨论ANSI C的输入和输出(I/O)函数。首先需要看两个错误和退出的函数。</p>
<h2 id="错误报错perror:">错误报错perror:</h2><blockquote>
<p>原型：void perror(char const *message);<br>头文件： &lt; stdio.h&gt; , &lt; stdlib.h&gt;</p>
</blockquote>
<p>如果message不是NULL，并且指向一个非空的字符串，perror函数就打印出这个字符串。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">FILE</span> *fp;</span><br><span class="line">fp = fopen(“/home/tianger/<span class="keyword">test</span>”,”r”);</span><br><span class="line"><span class="keyword">if</span>(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">     perror(“/home/tianger/<span class="keyword">test</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>/home/tianger/test：No such file or directory</p>
</blockquote>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/06/19/c-and-point-io/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/18/c-and-point-fourteen-define/" itemprop="url">
                  C与指针-第十四章--预处理器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-18T19:49:36+08:00" content="2016-06-18">
              2016-06-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/18/c-and-point-fourteen-define/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/18/c-and-point-fourteen-define/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>预处理器是在真正的编译开始之前由编译器调用的独立程序。预处理器可以删除注释、包含其他文件以及执行宏（宏macro是一段重复文字的简短描写）替代。预处理器可由语言（如C，PHP要求或以后作为提供额外功能（诸如为FORTRAN提供Ratfor预处理器）的附加软件。</p>
<h2 id="预定义宏">预定义宏</h2><p>ANSI C定义了一些宏。虽然每一个可以供您使用的编程，预定义宏不应该被直接修改。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DATE</strong></td>
<td style="text-align:center">“Jun 18 2016”</td>
<td style="text-align:center">文件被编译的时间</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td style="text-align:center">“15:47:03”</td>
<td style="text-align:center">文件被编译的时间</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td style="text-align:center">“test.c”</td>
<td style="text-align:center">进行编译的源文件名</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td style="text-align:center">“8”</td>
<td style="text-align:center">文件当前的行号</td>
</tr>
<tr>
<td><strong>STDC</strong></td>
<td style="text-align:center">“1”</td>
<td style="text-align:center">如果编译器遵循ANSI C，其值就为1，否则未定义</td>
</tr>
</tbody>
</table>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/06/18/c-and-point-fourteen-define/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/c-and-point-thirteen-function-point/" itemprop="url">
                  C与指针-第十三章-函数指针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-15T22:08:39+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/15/c-and-point-thirteen-function-point/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/15/c-and-point-thirteen-function-point/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文重点讲的函数指针为 回调函数和转移表。</p>
<h2 id="回调函数">回调函数</h2><h3 id="含义：">含义：</h3><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<h3 id="机制：">机制：</h3><blockquote>
<p>⑴定义一个回调函数；<br>⑵提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；<br>⑶当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</p>
</blockquote>
<h3 id="举例：">举例：</h3><p> 1.我们在路上遇到一个好多年没见到的朋友，要了朋友的手机好，跟他说我回去打给你</p>
<blockquote>
<p> 1)遇见朋友–主函数<br>  2)我打电话给朋友，通过朋友的手机号，找到朋友–(回调)</p>
</blockquote>
<p>2.寄快递的情形<br>   打电话给快递员，告诉他我的地址(理解成回调函数的地址)，快递员在有空的时候根据这个地址来找到你取件。</p>
<blockquote>
<p>1)打电话给快递员，告诉他我的地址–主函数(我的地址–回调函数地址)<br>  2)快递员处理完其他事情后，通过这个地址(回调)来找到你取件，执行完回调里面的内容。</p>
</blockquote>
<p>示例:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*回调函数*/</span></span><br><span class="line"><span class="keyword">void</span> *call_phone_number(<span class="keyword">int</span> number )</span><br><span class="line">&#123;</span><br><span class="line">      printf(<span class="string">"phone number = %d\n"</span>,number); <span class="comment">/*通过号码找到朋友*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_call</span>(<span class="params"> <span class="keyword">void</span> *call_back(<span class="keyword">int</span> number</span>))</span><br><span class="line"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> phone_number = <span class="number">12345</span>;</span><br><span class="line">      call_back(phone_number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">      start_call(call_phone_number);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="转移表">转移表</h2><p>用函数指针的形式来替换switch、if/else的方式</p>
<h3 id="示例：">示例：</h3><p>一个计算器实现<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">double add(double,double);</span><br><span class="line">double sub(double,double);</span><br><span class="line">double mul(double,double);</span><br><span class="line">double <span class="keyword">div</span>(double,double);</span><br><span class="line"></span><br><span class="line">     switch(oper)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">ADD</span>:</span><br><span class="line">               <span class="literal">result</span> = add(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">SUB</span>:</span><br><span class="line">               <span class="literal">result</span> = sub(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">MUL</span>:</span><br><span class="line">               <span class="literal">result</span> = mul(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">DIV</span>:</span><br><span class="line">               <span class="literal">result</span> = <span class="keyword">div</span>(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          default:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码改成转移表只需要两个步骤。<br>首先，声明并初始化一个函数指针数组。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double (*oper_func[])(double,double)=&#123;add,sub,mil,div&#125;;</span><br><span class="line"></span><br><span class="line">调用：</span><br><span class="line">result = oper_func[<span class="link_label">oper</span>](<span class="link_url">op1,op2</span>);</span><br></pre></td></tr></table></figure></p>
<p>oper从数组中选择正确的函数指针，而函数调用操作符将执行这个函数</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/c-and-point-twelve-linknode/" itemprop="url">
                  C与指针-第十二章 链表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T22:25:42+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/14/c-and-point-twelve-linknode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/c-and-point-twelve-linknode/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<h3 id="链表细则：">链表细则：</h3><p>1)是由结构体和指针构成的。<br>2)包括两个部分一个是数据域和指针域。<br>3)链表中的结点分为两类：头结点和一般结点。头结点是没有数据域的。<br>4)基本操作有：初始化链表，增加结点和删除结点，求链表的长度等等。</p>
<p>链表主要包括：单向链表，双向链表，循环链表。</p>
<h2 id="单向链表">单向链表</h2><h3 id="含义：">含义：</h3><p>单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始；链表是使用指针进行构造的列表；又称为结点列表，因为链表是由一个个结点组装起来的；其中每个结点都有指针成员变量指向列表中的下一个结点；<br>列表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向nuLL的指针。</p>
<h3 id="用法：">用法：</h3><p>//一个链表结构体的声明<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *next;</span><br><span class="line">	int	  data;</span><br><span class="line">&#125;Node;</span></span><br></pre></td></tr></table></figure></p>
<p>单链表的指向，链表的起始位置我们成为根指针(root)，它指向链表的第一个节点。根指针不包含任何数据，它只是一个指针。<br>Node *root;<br>下一个节点的访问通过root-&gt;next来实现<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/single-link.png" alt=""></p>
<h3 id="1-初始化链表：">1.初始化链表：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitNodeList</span><span class="params">(Node **node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//链表分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span>(!*node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	(*node)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：初始化时，这里的指针为二级指针，因为我们想要获取链表的根指针，如果只传入一级指针，malloc后得到的为分配内存的首地址给node，而不能被主函数中指针变量root得到这个地址。</p>
</blockquote>
<h3 id="2-插入数据：">2.插入数据：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">按值的大小顺序进行插入，把值插入到合适的位置</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> InsertNodeList(Node **root,<span class="keyword">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">  Node *current;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  Node *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">  current = *root;</span><br><span class="line">  <span class="keyword">previous</span> = <span class="keyword">NULL</span>; <span class="comment">/*用于判断新插入的值是否在第一个节点*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*寻找正确的插入位置，按序访问链表，直到到达一个其值大于或等于新值的节点*/</span></span><br><span class="line">  <span class="keyword">while</span>(current != <span class="keyword">NULL</span> &amp;&amp; current-&gt;data &lt; data)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">previous</span> = current;</span><br><span class="line">    current  = current-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*新节点分配内存空间*/</span></span><br><span class="line">  <span class="keyword">new</span> = (Node *)malloc(sizeof(Node));</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*新节点插入链表*/</span></span><br><span class="line">  <span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">  <span class="comment">/*如果插入的值在根节点，把新节点指向根节点，否则前一个节点，指向新节点*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">previous</span> == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *root = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">previous</span>-&gt;<span class="keyword">next</span> = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-获取链表长度">3.获取链表长度</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LengthNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  <span class="keyword">previous</span>=root-&gt;<span class="keyword">next</span>;<span class="comment">/*p指向链表的第一个结点。*/</span></span><br><span class="line">  <span class="comment">/*循环链表，直到节点为空*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">previous</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">previous</span>=<span class="keyword">previous</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除节点：">4.删除节点：</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void DestroyNodeList(Node <span class="keyword">*</span>root)</span><br><span class="line">&#123;</span><br><span class="line">  Node <span class="keyword">*</span>current,<span class="keyword">*</span>next;</span><br><span class="line">  current=root;/<span class="keyword">*</span>current 指向链表的根结点<span class="keyword">*</span>/</span><br><span class="line">  /<span class="keyword">*</span>当节点指向为空，即到了链表末尾，跳出<span class="keyword">*</span>/</span><br><span class="line">  while(current)</span><br><span class="line">  &#123;</span><br><span class="line">    next = current-&gt;next;/<span class="keyword">*</span>指向当前结点的下一个结点。<span class="keyword">*</span>/</span><br><span class="line">    free(current);/<span class="keyword">*</span>释放当前结点<span class="keyword">*</span>/</span><br><span class="line">    current = next;/<span class="keyword">*</span>指向下一个结点<span class="keyword">*</span>/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调用：">5.调用：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node *root;</span><br><span class="line">	<span class="keyword">int</span> node_length = <span class="number">0</span>;</span><br><span class="line">	InitNodeList(&amp;root);  <span class="comment">/*初始化链表，得到一个跟节点*/</span></span><br><span class="line">	InsertNodeList(&amp;root,<span class="number">10</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	node_length = LengthNodeList(root); <span class="comment">/*获取链表长度*/</span></span><br><span class="line">	DestroyNodeList(root); <span class="comment">/*销毁链表*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表">双向链表</h2><h3 id="含义：-1">含义：</h3><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<h3 id="特点：">特点：</h3><blockquote>
<pre><code><span class="number">1</span>）在数据结构中具有双向指针
<span class="number">2</span>）插入、删除数据的时候需要考虑前后的方向的操作
</code></pre></blockquote>
<h3 id="用法：-1">用法：</h3><p>一个链表结构体的声明<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">	int	  data;</span><br><span class="line">&#125;<span class="constant">Node</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xn24x.com1.z0.glb.clouddn.com/mutl-link.png" alt=""></p>
<h3 id="1-初始化链表：-1">1.初始化链表：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitNodeList</span><span class="params">(Node **node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//链表分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span>(!*node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	(*node)-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">	(*node)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.插入数据：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> InsertNodeList(register Node *root,<span class="keyword">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">  register Node *<span class="keyword">this</span>;</span><br><span class="line">  register Node *<span class="keyword">next</span>;</span><br><span class="line">  register Node *newnode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">this</span> = root;(<span class="keyword">next</span> = <span class="keyword">this</span>-&gt;<span class="keyword">next</span>)!= <span class="keyword">NULL</span>; <span class="keyword">this</span> =<span class="keyword">next</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">next</span>-&gt;data == data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">next</span>-&gt;data &gt; data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">/*新节点分配内存空间*/</span></span><br><span class="line">  newnode = (Node *)malloc(sizeof(Node));</span><br><span class="line">  <span class="keyword">if</span>(newnode == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*新节点插入链表*/</span></span><br><span class="line">  newnode-&gt;data = data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*插入新节点*/</span></span><br><span class="line">  newnode-&gt;<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="keyword">next</span> = newnode;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != root)</span><br><span class="line">  &#123;</span><br><span class="line">    newnode-&gt;prev = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    newnode-&gt;prev = <span class="keyword">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">next</span> != <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">next</span>-&gt;prev = newnode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    root-&gt;prev = newnode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-获取链表长度-1">3.获取链表长度</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LengthNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  <span class="keyword">previous</span>=root-&gt;<span class="keyword">next</span>;<span class="comment">/*p指向链表的第一个结点。*/</span></span><br><span class="line">  <span class="comment">/*循环链表，直到节点为空*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">previous</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">previous</span>=<span class="keyword">previous</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除节点：-1">4.删除节点：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DestroyNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  Node *current,*<span class="keyword">next</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  current=root;<span class="comment">/*current 指向链表的根结点*/</span></span><br><span class="line">  <span class="comment">/*当节点指向为空，即到了链表末尾，跳出*/</span></span><br><span class="line">  <span class="keyword">while</span>(current)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">next</span> = current-&gt;<span class="keyword">next</span>;<span class="comment">/*指向当前结点的下一个结点。*/</span></span><br><span class="line">    free(current);<span class="comment">/*释放当前结点*/</span></span><br><span class="line">    current = <span class="keyword">next</span>;<span class="comment">/*指向下一个结点*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调用：-1">5.调用：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node *root;</span><br><span class="line">	<span class="keyword">int</span> node_length = <span class="number">0</span>;</span><br><span class="line">	InitNodeList(&amp;root);  <span class="comment">/*初始化链表，得到一个跟节点*/</span></span><br><span class="line">	InsertNodeList(root,<span class="number">10</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	InsertNodeList(root,<span class="number">20</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	node_length = LengthNodeList(root); <span class="comment">/*获取链表长度*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,node_length);</span><br><span class="line">	DestroyNodeList(root); <span class="comment">/*销毁链表*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/11/c-and-point-eleven-malloc-and-free/" itemprop="url">
                  C与指针-第十一章—动态内存分配
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-11T22:22:28+08:00" content="2016-06-11">
              2016-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/11/c-and-point-eleven-malloc-and-free/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/11/c-and-point-eleven-malloc-and-free/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们使用数组时，它是存储于内存中连续的位置上，它所需要的内存在编译时就被分配，使用起来比较方便，但是也存在几个缺点。</p>
<h3 id="数组的缺点:">数组的缺点:</h3><p>1)假如一个数组无限大，而我们只需要很少的几个字节，这就会造成内存浪费，增加了内存的开销。<br>2)我们我们访问超过数组下标的内容时，造成数组越界，有可能产生一个异常值，从而导致失败。</p>
<p>针对这两点，动态内存分配的处理就相对比较适用。动态内存分配中使用的几个关键字<br>malloc和free，这两个是成对出现的，malloc用来申请内存空间，free用来释放内存。</p>
<h2 id="malloc和free">malloc和free</h2><p>malloc从内存池中提取一块合适的内存，并向该程序返回一个指向这块内存的指针。这块内存没有初始化。<br>当内存不再使用时，调用free把这块内存归还给内存池。</p>
<h3 id="原型：">原型：</h3><blockquote>
<p>void <em>malloc(size_t size);<br>void free(void </em>pointer);</p>
</blockquote>
<p>malloc的参数是需要分配的内存字节数。<br>malloc分配的是一块连续的内存。如果请求分配的是100个字节，那么实际分配的就是100个连续的字节，不会分开于两块或多块不同的内存。<br>如果内存池为空，或者申请内存不成功，malloc就会返回一个NULL指针。如果需要对分配的内存进行检查，可以通过与NULL指针进行比较来判断内存是否分配成功。</p>
<p>free的参数必须是从malloc、calloc或relloc返回的值，或者是NULL。传递NULL指针不会产生任何效果。</p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">...</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">100</span>);     <span class="comment">//申请内存空间</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0x0</span>,<span class="number">100</span>);  <span class="comment">//清空内存</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>)  <span class="comment">//判断内存是否申请成功</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(“out of memory!\n”);</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a); <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure></p>
<h2 id="calloc和relloc">calloc和relloc</h2><h3 id="原型：-1">原型：</h3><blockquote>
<p>void <em>calloc(size_t num_elements, size_t element_size);<br>void realloc(void </em>ptr,size_t new_size);</p>
</blockquote>
<p>calloc用于内存的申请。<br>calloc与malloc之间的主要区别是calloc在返回指向内存的指针之前把它初始化为0。但是如果你的程序知识想把一些值存储到数组中，那么这个初始化过程纯属浪费时间。</p>
<p>relloc函数用于修改一个原先已经分配的内存块大小。使用这个函数，你可以使一块内存扩大或缩小。如果它用于扩大一个内存块，那么这块内存原先的内容依然保留，新增加的内存添加到原先内存块的后面，新的内存并未以任何方式进行初始化。该内存块尾部的部分内存便被拿掉，剩余部分内存的原先内容依然被保留。</p>
<p>如果realloc函数的第1个参数是NULL，那么它的行为就和malloc一样。</p>
<h2 id="内存泄漏：">内存泄漏：</h2><p>当动态分配的内存不再需要使用时，它应该被释放。如果内存不释放，将会引起内存泄漏。内存泄漏可以一点点的榨干可用内存，从而导致程序崩溃。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/10/c-and-point-ten-struct/" itemprop="url">
                  C与指针-第十章-结构体\联合union
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-10T22:49:51+08:00" content="2016-06-10">
              2016-06-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/10/c-and-point-ten-struct/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/10/c-and-point-ten-struct/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。</p>
<h2 id="含义：">含义：</h2><p>结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。</p>
<h2 id="定义与声明：">定义与声明：</h2><p>结构体的定义如下所示，struct为结构体关键字，tag为结构体的标志，member-list为结构体成员列表，其必须列出其所有成员；variable-list为此结构体声明的变量。</p>
<blockquote>
<p>struct tag {<br>member-list<br>} variable-list ;</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;s2;</span><br><span class="line">注：s1和s2被编译器当做两种截然不同的类型，即使他们成员列表相同。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">用标签来创建变量：</span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span> x;</span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span> y[<span class="number">20</span>];</span><br><span class="line">这里x和y是两个完全相同的类型，因为他们用标签来进行定义</span><br></pre></td></tr></table></figure>
<h2 id="typedef：">typedef：</h2><p>声明结构体时可以使用的另一种良好技巧是用typedef创建一种新的类型。</p>
<blockquote>
<p>typedef struct{<br>     int a;<br>     char b;<br>     double c;<br>}s3;</p>
</blockquote>
<p>这个技巧和标签的效果几乎完全相同，区别在于s3现在是个类型名而不是个结构标签。以后的声明如下：</p>
<blockquote>
<p>s3 x;<br>s3 y[20];</p>
</blockquote>
<h2 id="结构成员：">结构成员：</h2><p>结构体的成员可以是标量、数组、指针甚至是其他结构体。</p>
<blockquote>
<p>typedef struct{<br>     int a;<br>     char b;<br>     double c:<br>     s3 d;<br>     s3 e[10];<br>}s4;</p>
</blockquote>
<h3 id="1)直接访问">1)直接访问</h3><p>结构体成员通过’.’操作符来访问的。<br>例：<br>s4 comp;</p>
<p>访问成员a， comp.a;<br>访问成员d中的a， comp.d.a;<br>访问成员e中第5个元素的成员a，comp.e[4].a;</p>
<h3 id="2)间接访问">2)间接访问</h3><p>如果拥有一个指向结构体的指针，那么我们访问结构体成员需要用’-&gt;’操作符来访问。<br>s4 *comp;</p>
<p>访问成员a， comp-&gt;a;<br>访问成员d中的a， comp-&gt;d.a;<br>访问成员e中第5个元素的成员a，comp-&gt;e[4].a;</p>
<h2 id="联合：">联合：</h2><h3 id="含义：-1">含义：</h3><p>“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>
<blockquote>
<p>联合使用关键字union来定义。</p>
</blockquote>
<h3 id="声明：">声明：</h3><p>联合声明跟结构体类似。<br>union {<br>     数据成员；<br>}变量；</p>
<blockquote>
<p>union{<br>      int a;<br>     float b;<br>}message；</p>
</blockquote>
<p>在一个32位的机器上，变量message只占用内存中最大的变量类型的大小，这里int跟float占用内存相同，因此变量message这里只占用内存中一个32位的字。<br>如果a被访问，这个字就作为int型访问；<br>如果b被访问，这个字就作为float型访问。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>.b = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">message</span>.a = <span class="number">10</span>;</span><br><span class="line">printf(“%d\n”,<span class="keyword">message</span>.a);</span><br><span class="line">printf(“%f\n”,<span class="keyword">message</span>.b);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>由于最后一个访问的是a，因此a打印的值为10，b的值为0.000000；反之相同</p>
</blockquote>
<h3 id="union和结构体：">union和结构体：</h3><p>通常我们把union和struct结合起来使用，这样更加方便我们的程序开发。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     int age;</span><br><span class="line">     int height;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     int year;</span><br><span class="line">     char class_name[<span class="number">10</span>];</span><br><span class="line">     <span class="class"><span class="keyword">enum</span> &#123;<span class="title">class1</span>,<span class="title">class2</span>&#125; <span class="title">type</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span>  <span class="title">first_student</span>;</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span>  <span class="title">second_student</span>;</span></span><br><span class="line">     &#125;data;</span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    int y;</span><br><span class="line">    int z;</span><br><span class="line">   <span class="regexp">/*msg相关变量赋值*/</span></span><br><span class="line">    msg.data.first_student.age = <span class="number">10</span>;</span><br><span class="line">    msg.data.first_student.height = <span class="number">170</span>;</span><br><span class="line">    msg.<span class="keyword">type</span> = class1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msg.<span class="keyword">type</span> == class1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">/*union一次只能访问一个成员*/</span></span><br><span class="line">         y = msg.data.first_student.age;</span><br><span class="line">         z = msg.data.first_student.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         y = msg.data.second_student.age;</span><br><span class="line">         z = msg.data.second_student.height;</span><br><span class="line">    &#125;</span><br><span class="line">      printf(<span class="string">"%d\n"</span>,y);  <span class="regexp">//</span>打印<span class="number">10</span></span><br><span class="line">      printf(<span class="string">"%d\n"</span>,z);  <span class="regexp">//</span>打印<span class="number">170</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结：">总结：</h2><p>1.结构体中，不同类型的值可以存储在一起，成员可以是标量、数组、指针或结构体<br>2.不同的二结构体声明即使它们的成员列表相同也被认为是不同的类型，typedef可以用于解决此问题<br>3.联合的所有成员都存储于同一个内存位置，通过访问不同类型的联合成员，内存中相同的位组合可以被解释为不同的东西。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/09/c-and-point-nine-char/" itemprop="url">
                  C与指针-第九章-字符、字符串处理API
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-09T23:08:16+08:00" content="2016-06-09">
              2016-06-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/09/c-and-point-nine-char/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/09/c-and-point-nine-char/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字符串是一种重要的数据类型，但是C语言并没有显式的字符串数据类型，因此字符串以字符串常量的形式出现或存储于字符数组中。字符串常量很适用于那些程序不会对它们进行修改的字符串。所有其他字符串都必须存储于字符数组或动态分配的内存中。本次主要描述处理字符串和字符的库函数。</p>
<p>字符串就是一串零个或多个字符，并且以一个位模式为全0的NUL字节结尾。因此，字符串所包含的字符内部不能出现NUL字节。<br>     字符、字符串处理需要引入string.h这个头文件</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span>
</code></pre><h2 id="1-字符串长度">1.字符串长度</h2><p>API: strlen<br>原型：size_t strlen(char const *string)<br>返回值:string字符串的长度，不包括结束符\0<br>作用：strlen返回一个类型为sizt_t的值，属于一个无符号整数类型。即为传入字符串的长度<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br></pre></td></tr></table></figure></p>
<p>这里i打印值为5，即为字符串hello的长度，不包含结束符。</p>
<p>尝试模仿strlen的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strlen(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*<span class="built_in">string</span>++ != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-复制字符串">2.复制字符串</h2><h3 id="1)不受长度限制">1)不受长度限制</h3><p>API：strcpy<br>原型：char <em>strcpy(char </em>dst,char const *src)<br>返回值：返回指向dst字符串的指针<br>作用：这个函数把参数src字符串复制到dst参数。如果参数src和dst在内存中出现重叠，其结果是未定义的。dst必须是一个字符数组或者是一个指向动态分配内存的数组的指针。<br>     src赋值给dst，dst以前的内容将会被覆盖丢失.如果src的长度超过了dst数组的长度，执行时会crash<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,<span class="string">"message"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line"> 输出内容为 message</span><br></pre></td></tr></table></figure></p>
<p>模仿strcpy的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制">2)长度受限制</h3><p>API:strncpy<br>原型：char <em>strncpy(char </em>dst, char const *src, size_t len);<br>返回值：返回指向dst字符串的指针<br>作用：把src字符串的字符复制到dst数组中。它总是正好向dst写入len个字符。如果strlen(src)的值小于len，dst数组会用额外的NUL字节填充到len长度。如果strlne(src)的值大于或等于len，那么只有len 个字符被复制到dst中。<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(buf,<span class="string">"A message"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">//输出A mes world，长度为5，其余的不拷贝</span></span><br><span class="line"><span class="built_in">strncpy</span>(buf,<span class="string">"A message"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">//输出A message</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strncpy的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strncpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src ,<span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len &amp;&amp; src[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-连接字符串">3.连接字符串</h2><h3 id="1)不受长度限制-1">1)不受长度限制</h3><p>API: strcat<br>原型：char <em>strcat(char </em>dst, const char *src);<br>返回：返回指向dst字符串的指针<br>作用：把src的字符串添加(连接)到dst字符串后面。这里要求dst原先已经包含了一个字符串(可以为空字符串)。它找到这个字符串的末尾。并把src字符串的一份拷贝添加到这个位置。如果src和dst的位置发生重叠，其结果是未定义的。<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = “hello”;</span><br><span class="line"><span class="built_in">strcat</span>(buf,”world”);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出helloworld</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strcat的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_stcat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制-1">2)长度受限制</h3><p>API: strncat<br>原型：char <em>strncat(char </em>dst, const char *src,size_t len);<br>返回值：指向dst的指针<br>作用：从src中复制长度为len个字符到dst中<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = “hello”;</span><br><span class="line"><span class="built_in">strncat</span>(buf,”world”,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出hellowo</span></span><br><span class="line"><span class="built_in">strncat</span>(buf,”world”,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出helloworld，超过部分遇到\0结束符，不再进行连接</span></span><br></pre></td></tr></table></figure></p>
<p>模拟strncat：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_stncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src,size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len &amp;&amp; (*dst++ = *src++) != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-字符串比较">4.字符串比较</h2><h3 id="1)不受长度限制-2">1)不受长度限制</h3><p>API: strcmp<br>原型：int strcmp(const char <em>s1, const char </em>s2)<br>返回值：0表示两个字符串相同，其余表示两个字符串不同<br>作用：对两个字符串s1\s2逐个字符进行比较，直到发现不匹配为止<br>用法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">ret</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">ret</span> = strcmp(buf,<span class="string">"hello”);</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">ret</span>);//输出<span class="number">0</span>，两个字符串相同</span><br><span class="line"><span class="keyword">ret</span> = strcmp(buf,”hello world<span class="string">");</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">ret</span>);//输出-<span class="number">32</span>，两个字符串不同</span><br></pre></td></tr></table></figure></p>
<p>模仿strcmp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strcmp(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">NULL</span>) || (s2 == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制-2">2)长度受限制</h3><p>API: strncmp<br>原型：int strcmp(const char <em>s1, const char </em>s2,size_t len)<br>返回值：0表示两个字符串相同，其余表示两个字符串不同<br>作用：对两个字符串s1\s2逐个字符进行比较，直到发现不匹配为止<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = <span class="built_in">strncmp</span>(buf,<span class="string">"hello"</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret); <span class="comment">//输出0，表示hello中前两个字符he跟hello中前两个相同</span></span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">strncmp</span>(buf,<span class="string">"hello world"</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret); <span class="comment">//输出-32，表示不相等，即hello world前8个字符，与hello不相等</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strncmp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strncmp(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * s2,<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">NULL</span>) || (s2 == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-字符串查找">5.字符串查找</h2><p>原型：char strstr(char <em>s1, char </em>s2)<br>返回值：NULL，或者指向查找到的起始位置的指针<br>作用：这个函数在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针。如果s2并没有完整地出现在s1的任何地方，函数将返回一个NULL指针，如果s2是一个空字符串，函数就返回是</p>
<p>用法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line">char *<span class="keyword">last</span> = NULL;</span><br><span class="line"><span class="keyword">last</span> = strstr(buf,<span class="string">"he”);</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="keyword">last</span>); //打印hello</span><br><span class="line"><span class="keyword">last</span> = strstr(buf,<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="keyword">last</span>); //打印null</span><br></pre></td></tr></table></figure></p>
<p>模拟strstr写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">my_strstr</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> * s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*s1 == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*s1 != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s2[i] == <span class="string">'\0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> s1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s2[i] != s1[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        s1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-内存操作：">6.内存操作：</h2><p>主要有memcpy、memmove、memcmp、memchr、memset几个函数</p>
<h3 id="原型：">原型：</h3><blockquote>
<p>void <em>memcpy(void </em>dst,void const <em>src,size_t length);<br>void </em>memmove(void <em>dst,void const </em>src,size_t length);<br>void <em>memcmp(void const </em>s1,void const <em>s2,size_t length);<br>void </em>memchr(void <em>s1,void const </em>s2,size_t length);<br>void <em>memset(void </em>dst,int ch,size_t length);</p>
</blockquote>
<h3 id="用法:">用法:</h3><h3 id="memcpy">memcpy</h3><p>从src的起始位置赋值length个字节到dst的内存起始位置，可以复制任何类型。如果src和dst出现重叠，其结果是未知的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dst[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> src[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(dst,src,<span class="built_in">strlen</span>(src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,dst );</span><br></pre></td></tr></table></figure></p>
<p>模拟memcpy：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_memcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> * src,size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) &amp;&amp; (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len-- &gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="memmove：">memmove：</h3><p>memmove用于从src拷贝count个字符到dest，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中。但复制后src内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。<br>用法：<br>char s[]=”Golden Global View”;<br>memmove(s,s+7,strlen(s)+1-7);<br>printf(“%s”,s);<br>程序输出结果：Global View<br>*注意：这里的拷贝长度strlen(s)+1-7表示把字符串结尾的’\0’也拷贝进来。</p>
<h3 id="memcmp">memcmp</h3><p>memcmp是比较内存区域buf1和buf2的前count个字节。该函数是按字节比较的。<br>返回值：<br>当s1<s2时，返回值<0 当s1="=s2时，返回值=0">s2时，返回值&gt;0</s2时，返回值<0></p>
<blockquote>
<p>如:char <em>s1=”abc”;<br>char </em>s2=”acd”;<br>int r=memcmp(s1,s2,3);<br>就是比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了。所以r=-1</p>
</blockquote>
<h3 id="memchr:">memchr:</h3><p>从buf所指内存区域的前count个字节查找字符ch。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s=<span class="string">"Hello, Programmers!"</span>;</span><br><span class="line"><span class="keyword">void</span> *p;<span class="comment">//因为memchr(,,);return void*p;</span></span><br><span class="line">p=<span class="built_in">memchr</span>(s,<span class="string">'P'</span>,<span class="built_in">strlen</span>(s));</span><br><span class="line"><span class="comment">//p=(char *)memchr(s,'P',sizeof(s)); //s是一个指向char的指针，而任何指针都是个一个4字节的数，在这里应//该是要说明搜索整个字符串的长度，所以应该用strlen(s)</span></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s"</span>,p);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Not Found!"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="memst">memst</h3><p>将s所指向的某一块内存中的前n个 字节的内容全部设置为ch指定的ASCII值<br>通常用来进行内存初始化作用<br>例如：<br>char dst[20];<br>memset(dst,0x0,sizeof(dst)); //把dst指向的大小为20的内存区域值都设置为0.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/07/c-and-point-eight/" itemprop="url">
                  C与指针-第八章-数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-07T22:22:28+08:00" content="2016-06-07">
              2016-06-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/07/c-and-point-eight/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/07/c-and-point-eight/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>所谓数组，就是相同数据类型的元素按一定顺序排列的集合，就是把有限个类型相同的变量用一个名字命名，然后用编号区分他们的变量的集合，这个名字称为数组名，编号称为下标。</p>
<p>特点：只能存放一种类型的数据，如全部是int型或者全部是char型，数组里的数据成为元素。</p>
<h2 id="一维数组：">一维数组：</h2><h3 id="格式：">格式：</h3><p>类型 数组名[元素个数-常量表达式]<br>（1）数组名的命名方法与变量名相同，遵循标识符命名规则;<br>（2）数组是用方括号括起来的常量表达式，不能用圆括号;<br>（3）常量表达式表示数组元素的个数，即数组的长度，数组的下标从0开始，下标的最大值为:<br>常量表达式-1;<br>（4）常量表达式中可以包括常量和符号常量，不能包括变量。<br>可以用赋值语句或输入语句使数组中的元素得到值，但要占用运行时间。可以使数组在运行之前初始化，即在编译阶段使之得到初值。</p>
<h3 id="初始化：">初始化：</h3><p>int buf[5] = {1,2,3,4,5};<br>这里把buf数组中的5个元素初始化为1,2,3,4,5</p>
<h3 id="下标：">下标：</h3><p>这里变量buf称为数组，因为它是一些值的集合，下标和数组名一起使用，用于标示该集合中的某个特定的值。例如buf[0]表示数组buf的第一个元素的值，这里值为1. buf[4]标示数组buf第5个值，这里值为5.<br>buf[0]  //对应的值为1<br>buf[4] //对应的值为5<br>数组的下标从0开始计数</p>
<h2 id="多维数组：">多维数组：</h2><p>某个数组的维数不止1个，我们称这个数组为多维数组</p>
<h3 id="格式：-1">格式：</h3><p>数组［下标］［下标］</p>
<p>在引用二维数组时，必须是单个元素，不能是整个数组名。下标可以是一个表达式，但不能是变量。如果下标是一个表达式，注意表达式的值不能超出数组定义的上、下限。</p>
<p>int num[3][5];<br>创建了一个包含15个元素的矩阵。我们一般把这个理解为3行5列，当然也可以理解为5行3列，为了我们方便记忆，我们看做为3行10列。</p>
<p>(1) 多维数组初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num[<span class="number">3</span>][<span class="number">5</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;,&#123;<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span>，<span class="number">10</span>&#125;,&#123;<span class="number">11</span>，<span class="number">12</span>，<span class="number">13</span>，<span class="number">14</span>，<span class="number">15</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上赋值把第一个花括号内的数据赋给第一行元素，第二个花括号内数据赋给第二元素，以此类推，即按行赋值</p>
<p>(2) 可以将所有的数据写在一个花括号内，按数组排列的顺序对各元素赋值。</p>
<p>(3)可以对数组的部分元素赋初值。如:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int a[<span class="link_label">3</span>][<span class="link_reference">5</span>]  = &#123;&#123;1&#125;,&#123;6&#125;，&#123;11&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上赋值的结果是:数组第一列的元素分别赋了初值1，6，11，其余元素的值都是0。<br>(4)如果对二维数组的全部元素都赋初值，则定义数组时对第一维的长度可以不指定，但第二维的长度不能省。</p>
<h2 id="指针数组_&amp;数组指针：">指针数组 &amp;数组指针：</h2><p>　　指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。<br>　　数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。</p>
<p>例：</p>
<h3 id="指针数组：">指针数组：</h3><blockquote>
<p>int <em>num1[10];<br>“[]”的优先级比“</em>”要高,num1先与“[]”结合，构成一个数组的定义，数组名为num1.int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。</p>
</blockquote>
<h3 id="数组指针：">数组指针：</h3><blockquote>
<p>int (<em>num2)[10];<br>在这里“()”的优先级比“[]”高，“</em>”号和num2 构成一个指针的定义，指针变量名为num2,int 修饰的是数组的内容，即数组的每个元素。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/05/c-and-pint-seven-function/" itemprop="url">
                  C与指针-第七章-函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-05T22:55:12+08:00" content="2016-06-05">
              2016-06-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C与指针/" itemprop="url" rel="index">
                    <span itemprop="name">C与指针</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/05/c-and-pint-seven-function/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/05/c-and-pint-seven-function/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>函数是指一段在一起的、可以做某一件事的程序，也叫子程序、方法。</p>
<h2 id="定义：">定义：</h2><blockquote>
<p>返回类型  函数名字(形式参数)<br>{<br>     代码块<br>}</p>
</blockquote>
<p>形式参数列表包括变量名和它们的类型声明。<br>代码块包含了局部变量的声明和相关执行语句。<br>compare.c中<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int max(int <span class="keyword">value</span><span class="number">_</span>left, int <span class="keyword">value</span><span class="number">_</span>right)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">_</span>left &gt; <span class="keyword">value</span><span class="number">_</span>right)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span><span class="number">_</span>left;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span><span class="number">_</span>right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数的类型声明为void，没有返回值；否则，需要相应类型的返回值。</p>
<h2 id="声明：">声明：</h2><p>当我们在一个源文件中定义的函数想被其他源文件使用的话，我们需要在头文件中声明这个函数，想调用这个函数的源文件中，include这个头文件即可。<br>.h文件中按如下方式进行声明。<br>返回类型  函数名字(形式参数)；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internel.h中</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> value_left ,<span class="keyword">int</span> value_right)</span></span>;</span><br><span class="line"></span><br><span class="line">在 main.c中使用</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> max_value;</span><br><span class="line">   max_value(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">   <span class="built_in">printf</span>(“max value is %d\n”,max_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数形参：">函数形参：</h2><p>C函数的所有参数均以“传值调用”方式进行传递。但是当我们传进来的参数为一个数组时，并在函数㕜使用下表引用该数组的参数，那么实际上函数对该数据的修改是调用程序中数组的元素，这个行为被称为“传址调用”。</p>
<p>下面这个数组，length为传值调用，array为传址调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (length &gt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">/*把数组的元组清零*/</span></span><br><span class="line">          <span class="built_in">array</span>[lengh] = <span class="number">0</span>;</span><br><span class="line">          length—;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="递归与迭代：">递归与迭代：</h2><h3 id="递归算法：">递归算法：</h3><p>直接或间接调用自身的函数。<br>把操作的内容放入栈，等函数递归完成后，出栈打印<br>下面这个简单的例子来说明递归调用方式。<br>程序作用：输入一个值，循环打印它的除以10 后剩余的值。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (input &gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span>(<span class="title">input</span></span>/<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(<span class="string">"%d\n"</span>,input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span>(1234);</span><br><span class="line">  <span class="title">return</span></span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>0<br>1<br>12<br>123<br>1234</p>
</blockquote>
<p>这里递归的操作依次为，先把第一个input放入栈，此时为1234；当再次调用时得到input的值，input为123，把123放入栈，一直大牌最后input的值为0，结束递归，打印时，先从栈顶取出数据，栈顶数据为0，栈底数据为1234，打印上面输出的结果<br>数据操作如下图所示：<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/c_function.png" alt=""></p>
<h3 id="迭代算法：">迭代算法：</h3><p>迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p>
<p>迭代算法是用计算机解决问题的一种基本方法。它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。</p>
<p>对于上面递归的算法，我们换成迭代来实现：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)</span><br><span class="line">&#123;</span><br><span class="line">   int ret;</span><br><span class="line">   <span class="keyword">while</span>(input &gt;<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     ret = input;</span><br><span class="line">     printf(<span class="string">"%d\n"</span>,ret);</span><br><span class="line">     input = input/<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结：">总结：</h3><p>递归的使用可以使代码更加简洁清晰，可读性更好，但由于递归需要系统堆栈，所以空间消耗比非递归代码要大很多。<br>理论上，递归与迭代在时间复杂度方面是等价的，但实际上递归的效率确实比迭代低。<br>一般情况下，能不用递归我们就尽量不使用递归，我们使用递归的先决条件是，当且仅当一个存在预期的收敛时，我们才使用递归算法，否则我们还是用迭代。</p>
<h2 id="可变参数：">可变参数：</h2><p>我们之前将的函数传进来的参数个数都是固定的，那么我们有没有办法，函数的参数有多个，但是我们只调用其中一部分呢，C的可变参数实现了这一功能。<br>     我们看下面这个例子，msg函数有多个参数，但是我们只调用其中一个，这种方式我们可以用在log打印上，可以打印不同类型的log，以及多个参数列表实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y…)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     msg(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C的可变参数使用，需要用到下面一些函数：<br>void va_start( va_list arg_ptr, prev_param );<br>type va_arg( va_list arg_ptr, type );<br>void va_end( va_list arg_ptr );</p>
<p>va_list:用来保存宏va_start、va_arg和va_end所需信息的一种类型。为了访问变长参数列表中的参数，必须声明va_list类型的一个对象       定义： typedef char *  va_list;</p>
<p>va_start:访问变长参数列表中的参数之前使用的宏，它初始化用va_list声明的对象，初始化结果供宏va_arg和 va_end使用；</p>
<p>va_arg: 展开成一个表达式的宏，该表达式具有变长参数列表中下一个参数的值和类型。每次调用va_arg都会修改用va_list声明的对象，从而使该对象指向参数列表中的下一个参数；</p>
<p>va_end:该宏使程序能够从变长参数列表用宏va_start引用的函数中正常返回。<br>va在这里是variable-argument(可变参数)的意思.</p>
<p>这些宏定义在stdarg.h中,所以用到可变参数的程序应该包含这个头文件.下面我们写一个简单的可变参数的函数,改函数至少有一个整数参数,第二个参数也是整数,是可选的.函数只是打印这两个参数的值.</p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_print</span><span class="params">(<span class="keyword">char</span> *msg,...)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    va_list arg_ptr; <span class="comment">/* 定义保存函数参数的结构 */</span></span><br><span class="line">    <span class="keyword">int</span> ipara =<span class="number">0</span>;      <span class="comment">/* 定义参数个数 */</span></span><br><span class="line">    <span class="keyword">char</span> *para = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>  flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arg_ptr指向传入的第一个可选参数，msg是最后一个确定的参数 */</span></span><br><span class="line">    va_start(arg_ptr, msg);</span><br><span class="line">    <span class="keyword">while</span>(*msg)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = *msg++;</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="string">'%'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(flag); <span class="comment">/*  如果字符不包括%号，把字符输出到终端上 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = *msg++; <span class="comment">/*  如果字符是%号，指针后移一位，判断对应格式 */</span></span><br><span class="line">        <span class="keyword">switch</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>: <span class="comment">/*  检索到%s，进行字符串的打印 */</span></span><br><span class="line">                para = va_arg(arg_ptr, <span class="keyword">char</span> *); <span class="comment">/*  取出当前的参数，类型为char *. */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>,para);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                ipara = va_arg(arg_ptr, <span class="keyword">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, ipara);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(arg_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    msg_print(<span class="string">"The first print %d\n"</span>,<span class="number">100</span>);</span><br><span class="line">    msg_print(<span class="string">"The second print %s,%d\n"</span>,<span class="string">"hello"</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>he first print 100<br>The second print hello,200</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xn24x.com1.z0.glb.clouddn.com/headphoto.png"
               alt="Tianger Ge" />
          <p class="site-author-name" itemprop="name">Tianger Ge</p>
          <p class="site-description motion-element" itemprop="description">3G/LTE protocol | C</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">52</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.github.com/tianger" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/tianger/" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tianger Ge</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tianger"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
