<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="3G/LTE protocol | C" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="3G/LTE protocol | C">
<meta property="og:type" content="website">
<meta property="og:title" content="Tianger's Family">
<meta property="og:url" content="http://tianger.github.io/page/2/index.html">
<meta property="og:site_name" content="Tianger's Family">
<meta property="og:description" content="3G/LTE protocol | C">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tianger's Family">
<meta name="twitter:description" content="3G/LTE protocol | C">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Tianger's Family </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3000033e6d5b1f1f2b431451efbce4ef";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Tianger's Family</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/10/c-and-point-ten-struct/" itemprop="url">
                C与指针-第十章-结构体\联合union
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-10T22:49:51+08:00" content="2016-06-10">
            2016-06-10
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/10/c-and-point-ten-struct/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/10/c-and-point-ten-struct/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。</p>
<h2 id="含义：">含义：</h2><p>结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。</p>
<h2 id="定义与声明：">定义与声明：</h2><p>结构体的定义如下所示，struct为结构体关键字，tag为结构体的标志，member-list为结构体成员列表，其必须列出其所有成员；variable-list为此结构体声明的变量。</p>
<blockquote>
<p>struct tag {<br>member-list<br>} variable-list ;</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;s2;</span><br><span class="line">注：s1和s2被编译器当做两种截然不同的类型，即使他们成员列表相同。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">用标签来创建变量：</span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span> x;</span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span> y[<span class="number">20</span>];</span><br><span class="line">这里x和y是两个完全相同的类型，因为他们用标签来进行定义</span><br></pre></td></tr></table></figure>
<h2 id="typedef：">typedef：</h2><p>声明结构体时可以使用的另一种良好技巧是用typedef创建一种新的类型。</p>
<blockquote>
<p>typedef struct{<br>     int a;<br>     char b;<br>     double c;<br>}s3;</p>
</blockquote>
<p>这个技巧和标签的效果几乎完全相同，区别在于s3现在是个类型名而不是个结构标签。以后的声明如下：</p>
<blockquote>
<p>s3 x;<br>s3 y[20];</p>
</blockquote>
<h2 id="结构成员：">结构成员：</h2><p>结构体的成员可以是标量、数组、指针甚至是其他结构体。</p>
<blockquote>
<p>typedef struct{<br>     int a;<br>     char b;<br>     double c:<br>     s3 d;<br>     s3 e[10];<br>}s4;</p>
</blockquote>
<h3 id="1)直接访问">1)直接访问</h3><p>结构体成员通过’.’操作符来访问的。<br>例：<br>s4 comp;</p>
<p>访问成员a， comp.a;<br>访问成员d中的a， comp.d.a;<br>访问成员e中第5个元素的成员a，comp.e[4].a;</p>
<h3 id="2)间接访问">2)间接访问</h3><p>如果拥有一个指向结构体的指针，那么我们访问结构体成员需要用’-&gt;’操作符来访问。<br>s4 *comp;</p>
<p>访问成员a， comp-&gt;a;<br>访问成员d中的a， comp-&gt;d.a;<br>访问成员e中第5个元素的成员a，comp-&gt;e[4].a;</p>
<h2 id="联合：">联合：</h2><h3 id="含义：-1">含义：</h3><p>“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>
<blockquote>
<p>联合使用关键字union来定义。</p>
</blockquote>
<h3 id="声明：">声明：</h3><p>联合声明跟结构体类似。<br>union {<br>     数据成员；<br>}变量；</p>
<blockquote>
<p>union{<br>      int a;<br>     float b;<br>}message；</p>
</blockquote>
<p>在一个32位的机器上，变量message只占用内存中最大的变量类型的大小，这里int跟float占用内存相同，因此变量message这里只占用内存中一个32位的字。<br>如果a被访问，这个字就作为int型访问；<br>如果b被访问，这个字就作为float型访问。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>.b = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">message</span>.a = <span class="number">10</span>;</span><br><span class="line">printf(“%d\n”,<span class="keyword">message</span>.a);</span><br><span class="line">printf(“%f\n”,<span class="keyword">message</span>.b);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>由于最后一个访问的是a，因此a打印的值为10，b的值为0.000000；反之相同</p>
</blockquote>
<h3 id="union和结构体：">union和结构体：</h3><p>通常我们把union和struct结合起来使用，这样更加方便我们的程序开发。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     int age;</span><br><span class="line">     int height;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     int year;</span><br><span class="line">     char class_name[<span class="number">10</span>];</span><br><span class="line">     <span class="class"><span class="keyword">enum</span> &#123;<span class="title">class1</span>,<span class="title">class2</span>&#125; <span class="title">type</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span>  <span class="title">first_student</span>;</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span>  <span class="title">second_student</span>;</span></span><br><span class="line">     &#125;data;</span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    int y;</span><br><span class="line">    int z;</span><br><span class="line">   <span class="regexp">/*msg相关变量赋值*/</span></span><br><span class="line">    msg.data.first_student.age = <span class="number">10</span>;</span><br><span class="line">    msg.data.first_student.height = <span class="number">170</span>;</span><br><span class="line">    msg.<span class="keyword">type</span> = class1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msg.<span class="keyword">type</span> == class1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">/*union一次只能访问一个成员*/</span></span><br><span class="line">         y = msg.data.first_student.age;</span><br><span class="line">         z = msg.data.first_student.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         y = msg.data.second_student.age;</span><br><span class="line">         z = msg.data.second_student.height;</span><br><span class="line">    &#125;</span><br><span class="line">      printf(<span class="string">"%d\n"</span>,y);  <span class="regexp">//</span>打印<span class="number">10</span></span><br><span class="line">      printf(<span class="string">"%d\n"</span>,z);  <span class="regexp">//</span>打印<span class="number">170</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结：">总结：</h2><p>1.结构体中，不同类型的值可以存储在一起，成员可以是标量、数组、指针或结构体<br>2.不同的二结构体声明即使它们的成员列表相同也被认为是不同的类型，typedef可以用于解决此问题<br>3.联合的所有成员都存储于同一个内存位置，通过访问不同类型的联合成员，内存中相同的位组合可以被解释为不同的东西。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/09/c-and-point-nine-char/" itemprop="url">
                C与指针-第九章-字符、字符串处理API
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-09T23:08:16+08:00" content="2016-06-09">
            2016-06-09
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/09/c-and-point-nine-char/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/09/c-and-point-nine-char/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>字符串是一种重要的数据类型，但是C语言并没有显式的字符串数据类型，因此字符串以字符串常量的形式出现或存储于字符数组中。字符串常量很适用于那些程序不会对它们进行修改的字符串。所有其他字符串都必须存储于字符数组或动态分配的内存中。本次主要描述处理字符串和字符的库函数。</p>
<p>字符串就是一串零个或多个字符，并且以一个位模式为全0的NUL字节结尾。因此，字符串所包含的字符内部不能出现NUL字节。<br>     字符、字符串处理需要引入string.h这个头文件</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span>
</code></pre><h2 id="1-字符串长度">1.字符串长度</h2><p>API: strlen<br>原型：size_t strlen(char const *string)<br>返回值:string字符串的长度，不包括结束符\0<br>作用：strlen返回一个类型为sizt_t的值，属于一个无符号整数类型。即为传入字符串的长度<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br></pre></td></tr></table></figure></p>
<p>这里i打印值为5，即为字符串hello的长度，不包含结束符。</p>
<p>尝试模仿strlen的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strlen(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*<span class="built_in">string</span>++ != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-复制字符串">2.复制字符串</h2><h3 id="1)不受长度限制">1)不受长度限制</h3><p>API：strcpy<br>原型：char <em>strcpy(char </em>dst,char const *src)<br>返回值：返回指向dst字符串的指针<br>作用：这个函数把参数src字符串复制到dst参数。如果参数src和dst在内存中出现重叠，其结果是未定义的。dst必须是一个字符数组或者是一个指向动态分配内存的数组的指针。<br>     src赋值给dst，dst以前的内容将会被覆盖丢失.如果src的长度超过了dst数组的长度，执行时会crash<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,<span class="string">"message"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line"> 输出内容为 message</span><br></pre></td></tr></table></figure></p>
<p>模仿strcpy的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制">2)长度受限制</h3><p>API:strncpy<br>原型：char <em>strncpy(char </em>dst, char const *src, size_t len);<br>返回值：返回指向dst字符串的指针<br>作用：把src字符串的字符复制到dst数组中。它总是正好向dst写入len个字符。如果strlen(src)的值小于len，dst数组会用额外的NUL字节填充到len长度。如果strlne(src)的值大于或等于len，那么只有len 个字符被复制到dst中。<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(buf,<span class="string">"A message"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">//输出A mes world，长度为5，其余的不拷贝</span></span><br><span class="line"><span class="built_in">strncpy</span>(buf,<span class="string">"A message"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">//输出A message</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strncpy的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strncpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src ,<span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len &amp;&amp; src[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-连接字符串">3.连接字符串</h2><h3 id="1)不受长度限制-1">1)不受长度限制</h3><p>API: strcat<br>原型：char <em>strcat(char </em>dst, const char *src);<br>返回：返回指向dst字符串的指针<br>作用：把src的字符串添加(连接)到dst字符串后面。这里要求dst原先已经包含了一个字符串(可以为空字符串)。它找到这个字符串的末尾。并把src字符串的一份拷贝添加到这个位置。如果src和dst的位置发生重叠，其结果是未定义的。<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = “hello”;</span><br><span class="line"><span class="built_in">strcat</span>(buf,”world”);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出helloworld</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strcat的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_stcat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制-1">2)长度受限制</h3><p>API: strncat<br>原型：char <em>strncat(char </em>dst, const char *src,size_t len);<br>返回值：指向dst的指针<br>作用：从src中复制长度为len个字符到dst中<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = “hello”;</span><br><span class="line"><span class="built_in">strncat</span>(buf,”world”,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出hellowo</span></span><br><span class="line"><span class="built_in">strncat</span>(buf,”world”,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出helloworld，超过部分遇到\0结束符，不再进行连接</span></span><br></pre></td></tr></table></figure></p>
<p>模拟strncat：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_stncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src,size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len &amp;&amp; (*dst++ = *src++) != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-字符串比较">4.字符串比较</h2><h3 id="1)不受长度限制-2">1)不受长度限制</h3><p>API: strcmp<br>原型：int strcmp(const char <em>s1, const char </em>s2)<br>返回值：0表示两个字符串相同，其余表示两个字符串不同<br>作用：对两个字符串s1\s2逐个字符进行比较，直到发现不匹配为止<br>用法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">ret</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">ret</span> = strcmp(buf,<span class="string">"hello”);</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">ret</span>);//输出<span class="number">0</span>，两个字符串相同</span><br><span class="line"><span class="keyword">ret</span> = strcmp(buf,”hello world<span class="string">");</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">ret</span>);//输出-<span class="number">32</span>，两个字符串不同</span><br></pre></td></tr></table></figure></p>
<p>模仿strcmp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strcmp(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">NULL</span>) || (s2 == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制-2">2)长度受限制</h3><p>API: strncmp<br>原型：int strcmp(const char <em>s1, const char </em>s2,size_t len)<br>返回值：0表示两个字符串相同，其余表示两个字符串不同<br>作用：对两个字符串s1\s2逐个字符进行比较，直到发现不匹配为止<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = <span class="built_in">strncmp</span>(buf,<span class="string">"hello"</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret); <span class="comment">//输出0，表示hello中前两个字符he跟hello中前两个相同</span></span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">strncmp</span>(buf,<span class="string">"hello world"</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret); <span class="comment">//输出-32，表示不相等，即hello world前8个字符，与hello不相等</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strncmp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strncmp(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * s2,<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">NULL</span>) || (s2 == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-字符串查找">5.字符串查找</h2><p>原型：char strstr(char <em>s1, char </em>s2)<br>返回值：NULL，或者指向查找到的起始位置的指针<br>作用：这个函数在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针。如果s2并没有完整地出现在s1的任何地方，函数将返回一个NULL指针，如果s2是一个空字符串，函数就返回是</p>
<p>用法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line">char *<span class="keyword">last</span> = NULL;</span><br><span class="line"><span class="keyword">last</span> = strstr(buf,<span class="string">"he”);</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="keyword">last</span>); //打印hello</span><br><span class="line"><span class="keyword">last</span> = strstr(buf,<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="keyword">last</span>); //打印null</span><br></pre></td></tr></table></figure></p>
<p>模拟strstr写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">my_strstr</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> * s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*s1 == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*s1 != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s2[i] == <span class="string">'\0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> s1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s2[i] != s1[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        s1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-内存操作：">6.内存操作：</h2><p>主要有memcpy、memmove、memcmp、memchr、memset几个函数</p>
<h3 id="原型：">原型：</h3><blockquote>
<p>void <em>memcpy(void </em>dst,void const <em>src,size_t length);<br>void </em>memmove(void <em>dst,void const </em>src,size_t length);<br>void <em>memcmp(void const </em>s1,void const <em>s2,size_t length);<br>void </em>memchr(void <em>s1,void const </em>s2,size_t length);<br>void <em>memset(void </em>dst,int ch,size_t length);</p>
</blockquote>
<h3 id="用法:">用法:</h3><h3 id="memcpy">memcpy</h3><p>从src的起始位置赋值length个字节到dst的内存起始位置，可以复制任何类型。如果src和dst出现重叠，其结果是未知的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dst[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> src[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(dst,src,<span class="built_in">strlen</span>(src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,dst );</span><br></pre></td></tr></table></figure></p>
<p>模拟memcpy：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_memcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> * src,size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) &amp;&amp; (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len-- &gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="memmove：">memmove：</h3><p>memmove用于从src拷贝count个字符到dest，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中。但复制后src内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。<br>用法：<br>char s[]=”Golden Global View”;<br>memmove(s,s+7,strlen(s)+1-7);<br>printf(“%s”,s);<br>程序输出结果：Global View<br>*注意：这里的拷贝长度strlen(s)+1-7表示把字符串结尾的’\0’也拷贝进来。</p>
<h3 id="memcmp">memcmp</h3><p>memcmp是比较内存区域buf1和buf2的前count个字节。该函数是按字节比较的。<br>返回值：<br>当s1<s2时，返回值<0 当s1="=s2时，返回值=0">s2时，返回值&gt;0</s2时，返回值<0></p>
<blockquote>
<p>如:char <em>s1=”abc”;<br>char </em>s2=”acd”;<br>int r=memcmp(s1,s2,3);<br>就是比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了。所以r=-1</p>
</blockquote>
<h3 id="memchr:">memchr:</h3><p>从buf所指内存区域的前count个字节查找字符ch。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s=<span class="string">"Hello, Programmers!"</span>;</span><br><span class="line"><span class="keyword">void</span> *p;<span class="comment">//因为memchr(,,);return void*p;</span></span><br><span class="line">p=<span class="built_in">memchr</span>(s,<span class="string">'P'</span>,<span class="built_in">strlen</span>(s));</span><br><span class="line"><span class="comment">//p=(char *)memchr(s,'P',sizeof(s)); //s是一个指向char的指针，而任何指针都是个一个4字节的数，在这里应//该是要说明搜索整个字符串的长度，所以应该用strlen(s)</span></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s"</span>,p);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Not Found!"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="memst">memst</h3><p>将s所指向的某一块内存中的前n个 字节的内容全部设置为ch指定的ASCII值<br>通常用来进行内存初始化作用<br>例如：<br>char dst[20];<br>memset(dst,0x0,sizeof(dst)); //把dst指向的大小为20的内存区域值都设置为0.</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/07/c-and-point-eight/" itemprop="url">
                C与指针-第八章-数组
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-07T22:22:28+08:00" content="2016-06-07">
            2016-06-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/07/c-and-point-eight/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/07/c-and-point-eight/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>所谓数组，就是相同数据类型的元素按一定顺序排列的集合，就是把有限个类型相同的变量用一个名字命名，然后用编号区分他们的变量的集合，这个名字称为数组名，编号称为下标。</p>
<p>特点：只能存放一种类型的数据，如全部是int型或者全部是char型，数组里的数据成为元素。</p>
<h2 id="一维数组：">一维数组：</h2><h3 id="格式：">格式：</h3><p>类型 数组名[元素个数-常量表达式]<br>（1）数组名的命名方法与变量名相同，遵循标识符命名规则;<br>（2）数组是用方括号括起来的常量表达式，不能用圆括号;<br>（3）常量表达式表示数组元素的个数，即数组的长度，数组的下标从0开始，下标的最大值为:<br>常量表达式-1;<br>（4）常量表达式中可以包括常量和符号常量，不能包括变量。<br>可以用赋值语句或输入语句使数组中的元素得到值，但要占用运行时间。可以使数组在运行之前初始化，即在编译阶段使之得到初值。</p>
<h3 id="初始化：">初始化：</h3><p>int buf[5] = {1,2,3,4,5};<br>这里把buf数组中的5个元素初始化为1,2,3,4,5</p>
<h3 id="下标：">下标：</h3><p>这里变量buf称为数组，因为它是一些值的集合，下标和数组名一起使用，用于标示该集合中的某个特定的值。例如buf[0]表示数组buf的第一个元素的值，这里值为1. buf[4]标示数组buf第5个值，这里值为5.<br>buf[0]  //对应的值为1<br>buf[4] //对应的值为5<br>数组的下标从0开始计数</p>
<h2 id="多维数组：">多维数组：</h2><p>某个数组的维数不止1个，我们称这个数组为多维数组</p>
<h3 id="格式：-1">格式：</h3><p>数组［下标］［下标］</p>
<p>在引用二维数组时，必须是单个元素，不能是整个数组名。下标可以是一个表达式，但不能是变量。如果下标是一个表达式，注意表达式的值不能超出数组定义的上、下限。</p>
<p>int num[3][5];<br>创建了一个包含15个元素的矩阵。我们一般把这个理解为3行5列，当然也可以理解为5行3列，为了我们方便记忆，我们看做为3行10列。</p>
<p>(1) 多维数组初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num[<span class="number">3</span>][<span class="number">5</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;,&#123;<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span>，<span class="number">10</span>&#125;,&#123;<span class="number">11</span>，<span class="number">12</span>，<span class="number">13</span>，<span class="number">14</span>，<span class="number">15</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上赋值把第一个花括号内的数据赋给第一行元素，第二个花括号内数据赋给第二元素，以此类推，即按行赋值</p>
<p>(2) 可以将所有的数据写在一个花括号内，按数组排列的顺序对各元素赋值。</p>
<p>(3)可以对数组的部分元素赋初值。如:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int a[<span class="link_label">3</span>][<span class="link_reference">5</span>]  = &#123;&#123;1&#125;,&#123;6&#125;，&#123;11&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上赋值的结果是:数组第一列的元素分别赋了初值1，6，11，其余元素的值都是0。<br>(4)如果对二维数组的全部元素都赋初值，则定义数组时对第一维的长度可以不指定，但第二维的长度不能省。</p>
<h2 id="指针数组_&amp;数组指针：">指针数组 &amp;数组指针：</h2><p>　　指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。<br>　　数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。</p>
<p>例：</p>
<h3 id="指针数组：">指针数组：</h3><blockquote>
<p>int <em>num1[10];<br>“[]”的优先级比“</em>”要高,num1先与“[]”结合，构成一个数组的定义，数组名为num1.int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。</p>
</blockquote>
<h3 id="数组指针：">数组指针：</h3><blockquote>
<p>int (<em>num2)[10];<br>在这里“()”的优先级比“[]”高，“</em>”号和num2 构成一个指针的定义，指针变量名为num2,int 修饰的是数组的内容，即数组的每个元素。</p>
</blockquote>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/05/c-and-pint-seven-function/" itemprop="url">
                C与指针-第七章-函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-05T22:55:12+08:00" content="2016-06-05">
            2016-06-05
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/05/c-and-pint-seven-function/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/05/c-and-pint-seven-function/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>函数是指一段在一起的、可以做某一件事的程序，也叫子程序、方法。</p>
<h2 id="定义：">定义：</h2><blockquote>
<p>返回类型  函数名字(形式参数)<br>{<br>     代码块<br>}</p>
</blockquote>
<p>形式参数列表包括变量名和它们的类型声明。<br>代码块包含了局部变量的声明和相关执行语句。<br>compare.c中<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int max(int <span class="keyword">value</span><span class="number">_</span>left, int <span class="keyword">value</span><span class="number">_</span>right)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">_</span>left &gt; <span class="keyword">value</span><span class="number">_</span>right)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span><span class="number">_</span>left;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span><span class="number">_</span>right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数的类型声明为void，没有返回值；否则，需要相应类型的返回值。</p>
<h2 id="声明：">声明：</h2><p>当我们在一个源文件中定义的函数想被其他源文件使用的话，我们需要在头文件中声明这个函数，想调用这个函数的源文件中，include这个头文件即可。<br>.h文件中按如下方式进行声明。<br>返回类型  函数名字(形式参数)；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internel.h中</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> value_left ,<span class="keyword">int</span> value_right)</span></span>;</span><br><span class="line"></span><br><span class="line">在 main.c中使用</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> max_value;</span><br><span class="line">   max_value(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">   <span class="built_in">printf</span>(“max value is %d\n”,max_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数形参：">函数形参：</h2><p>C函数的所有参数均以“传值调用”方式进行传递。但是当我们传进来的参数为一个数组时，并在函数㕜使用下表引用该数组的参数，那么实际上函数对该数据的修改是调用程序中数组的元素，这个行为被称为“传址调用”。</p>
<p>下面这个数组，length为传值调用，array为传址调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (length &gt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">/*把数组的元组清零*/</span></span><br><span class="line">          <span class="built_in">array</span>[lengh] = <span class="number">0</span>;</span><br><span class="line">          length—;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="递归与迭代：">递归与迭代：</h2><h3 id="递归算法：">递归算法：</h3><p>直接或间接调用自身的函数。<br>把操作的内容放入栈，等函数递归完成后，出栈打印<br>下面这个简单的例子来说明递归调用方式。<br>程序作用：输入一个值，循环打印它的除以10 后剩余的值。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (input &gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span>(<span class="title">input</span></span>/<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(<span class="string">"%d\n"</span>,input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span>(1234);</span><br><span class="line">  <span class="title">return</span></span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>0<br>1<br>12<br>123<br>1234</p>
</blockquote>
<p>这里递归的操作依次为，先把第一个input放入栈，此时为1234；当再次调用时得到input的值，input为123，把123放入栈，一直大牌最后input的值为0，结束递归，打印时，先从栈顶取出数据，栈顶数据为0，栈底数据为1234，打印上面输出的结果<br>数据操作如下图所示：<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/c_function.png" alt=""></p>
<h3 id="迭代算法：">迭代算法：</h3><p>迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p>
<p>迭代算法是用计算机解决问题的一种基本方法。它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。</p>
<p>对于上面递归的算法，我们换成迭代来实现：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)</span><br><span class="line">&#123;</span><br><span class="line">   int ret;</span><br><span class="line">   <span class="keyword">while</span>(input &gt;<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     ret = input;</span><br><span class="line">     printf(<span class="string">"%d\n"</span>,ret);</span><br><span class="line">     input = input/<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结：">总结：</h3><p>递归的使用可以使代码更加简洁清晰，可读性更好，但由于递归需要系统堆栈，所以空间消耗比非递归代码要大很多。<br>理论上，递归与迭代在时间复杂度方面是等价的，但实际上递归的效率确实比迭代低。<br>一般情况下，能不用递归我们就尽量不使用递归，我们使用递归的先决条件是，当且仅当一个存在预期的收敛时，我们才使用递归算法，否则我们还是用迭代。</p>
<h2 id="可变参数：">可变参数：</h2><p>我们之前将的函数传进来的参数个数都是固定的，那么我们有没有办法，函数的参数有多个，但是我们只调用其中一部分呢，C的可变参数实现了这一功能。<br>     我们看下面这个例子，msg函数有多个参数，但是我们只调用其中一个，这种方式我们可以用在log打印上，可以打印不同类型的log，以及多个参数列表实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y…)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     msg(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C的可变参数使用，需要用到下面一些函数：<br>void va_start( va_list arg_ptr, prev_param );<br>type va_arg( va_list arg_ptr, type );<br>void va_end( va_list arg_ptr );</p>
<p>va_list:用来保存宏va_start、va_arg和va_end所需信息的一种类型。为了访问变长参数列表中的参数，必须声明va_list类型的一个对象       定义： typedef char *  va_list;</p>
<p>va_start:访问变长参数列表中的参数之前使用的宏，它初始化用va_list声明的对象，初始化结果供宏va_arg和 va_end使用；</p>
<p>va_arg: 展开成一个表达式的宏，该表达式具有变长参数列表中下一个参数的值和类型。每次调用va_arg都会修改用va_list声明的对象，从而使该对象指向参数列表中的下一个参数；</p>
<p>va_end:该宏使程序能够从变长参数列表用宏va_start引用的函数中正常返回。<br>va在这里是variable-argument(可变参数)的意思.</p>
<p>这些宏定义在stdarg.h中,所以用到可变参数的程序应该包含这个头文件.下面我们写一个简单的可变参数的函数,改函数至少有一个整数参数,第二个参数也是整数,是可选的.函数只是打印这两个参数的值.</p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_print</span><span class="params">(<span class="keyword">char</span> *msg,...)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    va_list arg_ptr; <span class="comment">/* 定义保存函数参数的结构 */</span></span><br><span class="line">    <span class="keyword">int</span> ipara =<span class="number">0</span>;      <span class="comment">/* 定义参数个数 */</span></span><br><span class="line">    <span class="keyword">char</span> *para = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>  flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arg_ptr指向传入的第一个可选参数，msg是最后一个确定的参数 */</span></span><br><span class="line">    va_start(arg_ptr, msg);</span><br><span class="line">    <span class="keyword">while</span>(*msg)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = *msg++;</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="string">'%'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(flag); <span class="comment">/*  如果字符不包括%号，把字符输出到终端上 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = *msg++; <span class="comment">/*  如果字符是%号，指针后移一位，判断对应格式 */</span></span><br><span class="line">        <span class="keyword">switch</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>: <span class="comment">/*  检索到%s，进行字符串的打印 */</span></span><br><span class="line">                para = va_arg(arg_ptr, <span class="keyword">char</span> *); <span class="comment">/*  取出当前的参数，类型为char *. */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>,para);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                ipara = va_arg(arg_ptr, <span class="keyword">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, ipara);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(arg_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    msg_print(<span class="string">"The first print %d\n"</span>,<span class="number">100</span>);</span><br><span class="line">    msg_print(<span class="string">"The second print %s,%d\n"</span>,<span class="string">"hello"</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>he first print 100<br>The second print hello,200</p>
</blockquote>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/04/c-and-point-point/" itemprop="url">
                C与指针-第六章-指针
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-04T23:12:18+08:00" content="2016-06-04">
            2016-06-04
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/04/c-and-point-point/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/04/c-and-point-point/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="指针">指针</h2><h3 id="含义：">含义：</h3><p>在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p>
<p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址</p>
<blockquote>
<p>&amp;操作符：取变量的地址<br>*操作符：对指针做解引用操作</p>
</blockquote>
<h3 id="地址&amp;内存：">地址&amp;内存：</h3><p>计算机的内存由数以亿万技的位(bit)组成，每个位可以容纳0和1.</p>
<p>由于位的标示范围太有限，计算机中为了可以存储较大范围的值，通常把许多个位合成一组作为一个单位。在现代大多数的机器中，常用的是用8个位来组成一个单位，这里成为字节(byte)。1个字节可以存储无符号值0~255，或有符号值-128~127。</p>
<p> 其实字节标示的大小也比较有限，为了继续扩大存储的范围，我们把更多个字节组合在一起，作为一个更大的单位。</p>
<p> 例如：</p>
<blockquote>
<p>int   –4个字节   ，32位为4个字节<br>  float –4个字节<br>  long –4个字节<br>  long long —8个字节</p>
</blockquote>
<p>需要注意的：<br>1)内存中的每个位置由一个独一无二的地址标识<br>2)内存中的每个位置都包含一个值<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/c_point.png" alt=""></p>
<blockquote>
<p>int a =112,b = -1;<br>  float c = 3.14;<br>  int <em>d = &a;<br>  float </em>e = &c;</p>
<p>a,b,c,d,e分别表示什么<br>a是112，b为-1，c为3.14<br>d是指向int型的指针，这里指向a的地址，a的地址是100，所以d的值为100<br>e为指向float型的指针，这里指向c的地址，c的地址为108，所以e的值为108</p>
</blockquote>
<h3 id="间接访问操作符：">间接访问操作符：</h3><h4 id="含义：-1">含义：</h4><p>通过一个指针访问它所指向的地址的过程称为间接访问或解引用指针。</p>
<h4 id="操作符：对应的操作符为*">操作符：对应的操作符为*</h4><p>例如：<br>我们上面一节中的d为100，<em>d即为间接访问，</em>d的值为int类型，d的值为100，<em>d标示访问内存位置100并查看哪里的值，因此</em>d的右值为112.</p>
<p>未初始化和非法的指针：<br> 下面这个代码有没有问题：</p>
<blockquote>
<p> int <em>a;
 </em>a = 10;</p>
</blockquote>
<p>语句描述：这个语句声明创建了一个名叫a的指针变量。<br> *a = 10表示把12 存储到a所指向的内存位置。</p>
<p>正常编译这个语句没有问题，但是在正常使用的过程中，会存在一些隐患。这里的a没有做初始化，那么a指向哪个地址我们不清楚，所以这个10存储到哪个内存区域，其实我们也不能清楚的知道。</p>
<pre><code><span class="blockquote">&gt; 如果指针变量是静态的，它会自动初始化为0</span>
<span class="blockquote">&gt; 如果指针变量是自动的，那它根本不会被初始化。</span>
</code></pre><p>所以当，赋值操作进行时，如果a的初值是个非法地址，这个语句将会出错，程序终止；如果a的初值是个合法地址，那么地址上的值被修改，但是我们不确定那个地址是否是我们想要修改的地方。<br>     所以，在对指针进行间接访问之前，要确保它已经初始化。</p>
<h3 id="空指针：">空指针：</h3><p>含义：表示不指向任何东西(地址或内容)<br>用法：要使一个指针变量位NULL，就需要给它赋一个零值。<br>         想要测试一个指针是否为空，我们需要拿它与零值进行比较。这个零值由源代码约定得出。<br>     指针与零值比较来判断是否为空，我们最好用!这个符号来表示，这样可以排除隐士类型转换，也增强了可读性<br>例如：</p>
<blockquote>
<p>int a = 10;<br>int *b = &a;<br>if (!b)<br>{<br>  printf(“point p is not null\n”);<br>}</p>
</blockquote>
<h3 id="指针的指针:">指针的指针:</h3><p>我们用**来进行表示指针的指针，例如：</p>
<blockquote>
<p>int a = 10;<br>int <em>b = &a;<br>int *</em>c = &b;</p>
</blockquote>
<p>假设a的地址为101<br>那么b = 101, <em>b = 10;<br>**c相当于</em>(<em>c),我们必须从里向外逐成求值。</em>c访问c所指向的位置，即为变量b，为101，<em>(</em>c)这个间接访问操作，即访问c所指向位置的地址，这里就死&amp;b，就是变量a，值为10.</p>
<h3 id="指针运算:">指针运算:</h3><p> 指针运算包括 算数运算和关系运算：</p>
<h4 id="运算符：+_,-,++,—">运算符：+ ,-,++,—</h4><p>   这种形式只能用于指向数组中某个元素的指针，结果类型也是指针。<br>   指针的算数运算都需要操作一段连续的内存空间，例如数组</p>
<h4 id="指针运算：+，++">指针运算：+，++</h4><blockquote>
<p> int   value[5]<br>   int   *p;<br>  (1) p = &amp;value[0];//p指向value数组的第一个元素<br>      P += 2;  //p向后偏移两个int长度的位置，即指向了value数组的第三个元素</p>
<p>(2) for (p = &amp;value[0]; p&lt; &amp;value[5];)<br>     {<br>          <em>p++ =0;   //这边先进行</em>p = 0的操作，即把value[0]赋初值为0，再指针后移一位，循环初始化value这个数组<br>     }</p>
</blockquote>
<p>   当p这个指针指向的地址大于value[5]的地址，循环结束，p &lt;&amp;value[5],这里经过了5此循环后，p就指向了value数组最后一个数组外面的那个地址，指针可能可以合法的获取这个值，但对它执行简介访问操作可能意外的原先存储于这个位置的变量，我们一般不知道这个变量是什么，因此，这种情况下，一般不允许对指向这个位置的指针进行间接操作，即*p = 10这种操作</p>
<h4 id="指针运算:_-，–">指针运算: -，–</h4><p>  指针相减运算，只适用于数组的操作，即两个指针都指向同一个数组中的元素时，才允许一个指针减去另一个指针。</p>
<blockquote>
<p>int   value[5]<br>   int   <em>p;<br>  (1) p = &amp;value[4];//p指向value数组的第一个元素<br>      P -= 2;  //p向前偏移两个int长度的位置，即指向了value数组的第三个元素<br> (2) for (p = &amp;value[4]; p&gt;= &amp;value[0]; p–)<br>     {
          </em>p =0;   //这边先进行*p = 0的操作，即把value[4]赋初值为0，再指针减减，向前移动一位，循环初始化value这个数组<br>     }</p>
</blockquote>
<p>当p这个指针指向的地址小于value[0]的地址，循环结束，p &gt; = &amp;value[0],经过5次循环后，p指针指向了数组第一个元素之前,这里我们同样不能再对p这个指针进行间接操作。</p>
<h3 id="总结：">总结：</h3><p>1)未初始化的指针变量，不能进行解引用操作<br>2)初始化为NULL的指针，不能进行解引用操作<br>3)指针进行加减法操作后，指向了数组外面的内存地址后，不能对它们进行间接操作<br>4)指针的减法操作只能针对同一个数组的元素进行</p>
<p>=========================<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/02/c-and-point-five/" itemprop="url">
                C与指针-第五章左移、右移操作
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-02T22:09:46+08:00" content="2016-06-02">
            2016-06-02
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/02/c-and-point-five/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/02/c-and-point-five/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本文参考了<a href="http://www.cnblogs.com/myblesh/articles/2431806.html" target="_blank" rel="external">京月飞鸿的《C语言中的左移与右移》</a></p>
<h2 id="左移操作:">左移操作:</h2><h3 id="含义：">含义：</h3><p>顾名思义就是把一个数的所有位都向左移动若干位，在C用用&lt;&lt;运算符标记<br>例：</p>
<blockquote>
<p>int i = 1;<br>i = i &lt;&lt; 2</p>
</blockquote>
<p>1的二进制为00000001(这里用8位标示，不同系统，不同的位数)，向左移两位，即把1向左移动两位，后面补两个0<br>即 00000100,转换成10进制就变成了4</p>
<p>需要注意的是，int类型为有符号的类型，最左端的1位是符号位,即0正1负,那么移位的时候就会出现溢出<br>例：</p>
<blockquote>
<p>int i  = 0x40000000; //二进制位01000000000000000000000000000000<br>i = i &lt;&lt; 1</p>
</blockquote>
<p>i左移1位后变为0x80000000，符号位被置为了1，其它位全是0，变成了int所能表达的最小值，32位的int为-2147483648，溢出。<br>如果此时i再左移1位后，丢弃了最高为后，i变成了0</p>
<h2 id="右移操作：">右移操作：</h2><h3 id="含义：-1">含义：</h3><p>顾名思义就是把一个数的所有位都向右移动若干位，在C用用&gt;&gt;运算符标记<br>右移分为逻辑右移动和算术右移。</p>
<h3 id="逻辑右移：">逻辑右移：</h3><p>方法：<br>左边移入的位用0填充<br>int i = 150;//二进制为10010110<br>i = i&gt;&gt;2;<br>i向右移动两位，则最后面两位移除，最开始的添加两个0，变成00100101，十进制为37</p>
<h3 id="算术右移：">算术右移：</h3><p>方法：<br>左边移入的位由原先该值的符号位决定，符号位为1则移入的位均为1，符号位为0，则移入的位都为0，这样能够保持原数的正负数形式不变。<br>int i = 150;//二进制为10010110<br>i = i&gt;&gt;2;<br>i向右移动两位，原来的符号位即首位为1，即最后两位移除，最开始添加两个符号位，这里为1，即变成11100101，十进制为229</p>
<h2 id="总结：">总结：</h2><p>左移时总是移位和补零。右移时无符号数是移位和补零，此时称为逻辑右移;<br>而有符号数大多数情况下是移位和补最左边的位（也就是补最高有效位），移几位就补几位,此时称为算术右移</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/01/c-and-point-three-and-four/" itemprop="url">
                C与指针-第三、四章const\extern\static
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-01T21:56:19+08:00" content="2016-06-01">
            2016-06-01
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/01/c-and-point-three-and-four/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/01/c-and-point-three-and-four/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>C与指针第三章重点需要掌握的是 const\extern\static  这三个修饰关键字。<br>第四章主要讲的是if\while\switch\for\do..while\goto等常用语句的用法，这作为基础内容，本章就不进行讲解。</p>
<h2 id="const:">const:</h2><p>const关键字是一个很常用的关键字，它限定一个变量不允许被改变，产生静态作用。</p>
<h3 id="定义：">定义：</h3><p>const修饰的数据类型是指常类型，常类型的变量或对象的值是不能被更新的。</p>
<h3 id="目的：">目的：</h3><p>const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。</p>
<h3 id="用法：">用法：</h3><h4 id="1-基本用法">1.基本用法</h4><p>const int a = 10;<br>含义：定义了一个int类型的常量a,值为1，a为只读变量，程序允许过程中不能够直接修改它的值，即编译器编译经过类型检查后，直接用10在编译时替换，这使得编译器编译const常量过程中，少了一步存储与读内存的操作，提高了效率</p>
<h4 id="2-指针">2.指针</h4><p>  int b = 10;<br> 1)const int <em>a =&b;<br> 2)int const </em>a = &b;<br> 3)int <em> const a = &b;<br>含义：<br>1)表示指针所指向的对象是只读的(</em>a 只读),a指向的内容不能够通过a改变</p>
<blockquote>
<p><em>a = </em>a +1; //错误，*a为只读，不能被赋值</p>
</blockquote>
<p>2)与1)完全相同<br>3)表示指针指向是常量，不能够修改去指向其他内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c =<span class="number">20</span>;</span><br><span class="line"> a = &amp;c; <span class="comment">//错误，a为只读，不能指向其他内容</span></span><br><span class="line"> *a = *a +<span class="number">1</span>; <span class="comment">//正确， *a不为只读</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-函数">3.函数</h4><p>   1)修饰函数参数<br>      void foo(const int a);<br>      含义：传进来的a为只读，不能被修改<br>      void foo(const int <em>a);<br>      含义：传进来的</em>a 为只读，不能被修改，同上用于把数据作为参数传进来，函数只能读取这个指针的内容，当函数返回内部的类型时，已经是一个数值，当然不可被赋值更新，因此这种写法无意义</p>
<p>2)修饰函数返回值<br>    const int foo();<br>    含义：返回值为const类型，指返回的原函数里的变量初值不能被修改</p>
<h4 id="4-类型检查">4.类型检查</h4><p>const的值只能赋值给const对象，不能赋值给非const对象，只能强制类型转换才可以<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *a = &amp;b; <span class="comment">//错误，a为非const对象，b为const对象</span></span><br><span class="line"><span class="keyword">int</span> *a = (<span class="keyword">int</span> *)&amp;b; <span class="comment">//正确，强制类型转换</span></span><br></pre></td></tr></table></figure></p>
<h2 id="extern:">extern:</h2><h3 id="定义：-1">定义：</h3><p>extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。通过这种行为它告诉编译器：该变量/函数的定义已经存在在某个地方了，让编译器到其他的模块去寻找它的定义。</p>
<h3 id="用法：-1">用法：</h3><p>extern用在变量声明中常常有这样一个作用：你要在<em>.c文件中引用另一个文件中的一个全局的变量，那就应该放在</em>.h中用extern来声明这个全局变量。<br>在定义函数的时候，这个extern可以被省略，函数的默认定义就是extern类型</p>
<blockquote>
<p>extern int a;//声明一个全局变量a ，这是一个声明，只有这样写，才能被其他的C调用</p>
<p>int a; //定义一个全局变量a    ，这是一个定义，这不能被其他C调用</p>
<p>extern int a =0 ;//定义一个全局变量a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间。</p>
<p>i nt a =0;//定义一个全局变量a,并给初值，<br>声明之后你不能直接使用这个变量，需要定义之后才能使用。</p>
</blockquote>
<h2 id="static:">static:</h2><p>static内容参考了<br><a href="http://blog.csdn.net/keyeagle/article/details/6708077/" target="_blank" rel="external">keyeagle的《C语言static分析》</a><br><a href="http://blog.csdn.net/adriano119/article/details/2991317" target="_blank" rel="external">adriano119的《static用法总结》</a></p>
<h1 id="一个进程在内存中的布局入下图所示:">一个进程在内存中的布局入下图所示:</h1><pre><code><span class="header">|        栈区     |
------------------</span>
<span class="header">| 堆栈增长区  |
------------------</span>
<span class="header">|       堆区       |
-----------------</span>
<span class="header">|      其他段     |
-----------------</span>
<span class="header">|        .bss段      |
-----------------</span>
<span class="header">|        .data段     |
-----------------</span>
<span class="header">|        .text段     |
==========</span>
</code></pre><p>  其中.text段保存进程所执行的程序二进制文件，.data段保存进程所有的已初始化的全局变量，.bss段保存进程未初始化的全局变量（其他段中还有很多乱七八糟的段，暂且不表）。在进程的整个生命周期中，.data段和.bss段内的数据时跟整个进程同生共死的，也就是在进程结束之后这些数据才会寿终就寝。</p>
<p>一般程序的由malloc/new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区,全局变量和static变量放在.data段内(已初始化)或.bss段内(未初始化)，但是它只在定义它的源文件内有效，其他源文件无法访问它</p>
<h3 id="1、[静态全局变量]">1、[静态全局变量]</h3><p>//在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。<br> 静态全局变量有以下特点：<br>        1)该变量在全局数据区分配内存；<br>        2)未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；<br>        3)静态全局变量在声明它的整个文件都是可见的，而在文件之外(extern)是不可见的；<br>  定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：</p>
<blockquote>
<pre><code><span class="number">1</span>)静态全局变量不能被其它文件所用；
<span class="number">2</span>)其它文件中可以定义相同名字的变量，不会发生冲突；
</code></pre></blockquote>
<p>示例：<br>test1.c中,静态全局变量ch,只能在test1.c中使用，其他c文件不能使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="keyword">char</span> *ch = <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printstr</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2.<span class="function">c</span><br><span class="line"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,ch);  <span class="comment">//这里会报错，因为这个ch为test.c中的全局变量，只能在test1.c中使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、[静态局部变量]">2、[静态局部变量]</h3><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。</p>
<p>在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。每次调用这个局部变量在栈上的位置都不一定相同。如果我们想再两次的调用期间保留这个局部变量，就变的不可靠，一种方法使定义全局变量，另一个版本是使用静态局部变量</p>
<p>静态局部变量保存在全局数据区，即.data段或.bss段，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<p>静态局部变量有以下特点：</p>
<blockquote>
<p>1)该变量在全局数据区分配内存；<br>2)静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；<br>3)静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；<br>4)它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</p>
</blockquote>
<h3 id="3、静态函数">3、静态函数</h3><p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p>
<p>定义静态函数的好处：</p>
<blockquote>
<p>1)静态函数不能被其它文件所用；<br>2)其它文件中可以定义相同名字的函数，不会发生冲突；</p>
</blockquote>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/05/31/c-and-point-two/" itemprop="url">
                C与指针-第二章 转义字符
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-05-31T21:43:32+08:00" content="2016-05-31">
            2016-05-31
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/05/31/c-and-point-two/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/31/c-and-point-two/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>C与指针第二章的重点就是转义字符和编程风格，这里只列举一下我们常用的转义字符，至于编程风格，这个可以根据不同的平台有不同的风格，谷歌与微软的风格不相同，但有一点我们要记住，就是需要与我们编写的工程代码中的风格保持一致。</p>
<p>所有的ASCII码都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加”\”来表示常见的那些不能显示的ASCII字符，如\0,\t,\n等，就称为转义字符，因为后面的字符，都不是它本来的ASCII字符意思了。<br>8进制，16进制转义字符</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th style="text-align:center">意义</th>
<th style="text-align:center">ASCII码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td style="text-align:center">响铃(BEL)</td>
<td style="text-align:center">007</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:center">退格(BS)</td>
<td style="text-align:center">008</td>
</tr>
<tr>
<td>\f</td>
<td style="text-align:center">换页(FF)</td>
<td style="text-align:center">012</td>
</tr>
<tr>
<td>\n</td>
<td style="text-align:center">换行(LF)</td>
<td style="text-align:center">010</td>
</tr>
<tr>
<td>\r</td>
<td style="text-align:center">回车(CR)</td>
<td style="text-align:center">013</td>
</tr>
<tr>
<td>\t</td>
<td style="text-align:center">水平制表(HT)</td>
<td style="text-align:center">009</td>
</tr>
<tr>
<td>\v</td>
<td style="text-align:center">垂直制表(VT)</td>
<td style="text-align:center">011</td>
</tr>
<tr>
<td>\</td>
<td style="text-align:center">代表一个反斜线字符’’\’</td>
<td style="text-align:center">092</td>
</tr>
<tr>
<td>\’</td>
<td style="text-align:center">代表一个单引号（撇号）字符</td>
<td style="text-align:center">039</td>
</tr>
<tr>
<td>\”</td>
<td style="text-align:center">代表一个双引号字符</td>
<td style="text-align:center">034</td>
</tr>
<tr>
<td>\?</td>
<td style="text-align:center">代表一个问号</td>
<td style="text-align:center">063</td>
</tr>
<tr>
<td>\0</td>
<td style="text-align:center">空字符(NULL)</td>
<td style="text-align:center">000</td>
</tr>
<tr>
<td>\ddd</td>
<td style="text-align:center">1到3位八进制数所代表的任意字符</td>
<td style="text-align:center">三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td style="text-align:center">1到2位十六进制所代表的任意字符</td>
<td style="text-align:center">二位十六进制</td>
</tr>
</tbody>
</table>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a,b,c;</span><br><span class="line">     a=<span class="number">1</span>; b=<span class="number">2</span>; c=<span class="number">3</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\n\t%d %d\n %d %d\t\b%d\n"</span>,a,b,c,a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序练习转义字符的使用：<br>a、b、c分别为整数1,2,3<br>调用printf显示程序运行结果：<br>1<br>23<br>12 3</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/05/30/c-and-point-one/" itemprop="url">
                C与指针-第一章scanf\strncpy\strcpy\memcpy
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-05-30T21:50:41+08:00" content="2016-05-30">
            2016-05-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/05/30/c-and-point-one/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/30/c-and-point-one/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>第一章的主要重点是，如何从键盘进行输入、以及相应的字符串拷贝。<br>这里主要用到四个C的基础API–scanf\strcpy\strncpy\memcpy</p>
<p>scanf<br>作用： 是格式输入函数，即按用户的制定格式从键盘上把数据输入到制定变量中<br>头文件： #include <stdio.h><br>调用形式：scanf(“&lt;格式说明字符串&gt;”，&lt;变量地址&gt;);<br>注意第二个参数是一个地址，记得加&amp;符号，假如你是一个数组，不需要加入&amp;符号，如果是一个数组带下表，需要加上<br>int column[8];<br>int num;<br>scanf(“%d”,&amp;num)<br>scanf(“%d”,coloumn);<br>scanf(“%d”,&amp;coloumn[1]);</stdio.h></p>
<p>例如：<br>scanf(“%d %d”,&amp;a,&amp;b);<br>如果a和b都被成功读入，那么scanf的返回值就是2<br>如果只有a被成功读入，返回值为1<br>如果a和b都未被成功读入，返回值为0<br>如果遇到错误或遇到end of file，返回值为EOF。<br>且返回值为int型.</p>
<p>&amp;a,&amp;b,&amp;c中的&amp;是地址运算符，&amp;a指a在内存中的地址。scanf的作用是：按照a，b，c的内存地址将输入的数据存到a，b，c中去。变量a，b，c的地址是在编译连续阶段分配的（存储顺序由编译器决定）。</p>
<p>注意部分：<br>如果scanf中%d是连着写的如“%d%d%d”,在输入数据时，数据之间不可以加逗号，只能是空格或tab键或者回车键——“2 3 4” 或 “2（按tab）3（按tab）4（按tab）”。若是“%d，%d，%d”，则在输入数据时需要加“，”，如“2，3，4”.</p>
<p>相关输入格式<br>变量  类型<br>%d   int<br>%ld  long<br>%f    float<br>%lf   double<br>%c   char<br>%s   char数组</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%f,%c"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a=%d,b=%f,c=%c\n"</span>,a,b,c);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%f %c"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a1=%d,b1=%f,c1=%c\n"</span>,a,b,c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输入：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2.3</span>,d <span class="comment">//输入</span></span><br><span class="line">a=<span class="number">1</span>,b=<span class="number">2.300000</span>,c=d <span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">2.4</span> e <span class="comment">//输入</span></span><br><span class="line">a1=<span class="number">1</span>,b1=<span class="number">2.400000</span>,c1=e <span class="comment">//输出</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>strcpy函数：顾名思义字符串复制函数：原型：extern char <em>strcpy(char </em>dest,char *src); 功能：把从src地址开始且含有NULL结束符的字符串赋值到以dest开始的地址空间，返回dest（地址中存储的为复制后的新值）。要求：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。<br>一般函数原型实现方式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * strDest,<span class="keyword">const</span> <span class="keyword">char</span> * strSrc)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> * strDestCopy=strDest; <span class="comment">//[3]</span></span><br><span class="line"><span class="keyword">if</span> ((strDest==<span class="literal">NULL</span>)||(strSrc==<span class="literal">NULL</span>)) <span class="comment">//[1]</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Invalid argument(s)"</span>; <span class="comment">//[2]</span></span><br><span class="line"><span class="keyword">while</span> ((*strDest++=*strSrc++)!=<span class="string">'\0'</span>); <span class="comment">//[4]</span></span><br><span class="line"><span class="keyword">return</span> strDestCopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>该函数的参数是字符指针，也就是可以是字符串变量和字符数组，因为它们的变量名代表首字符地址。字符串默认有一个null结束符，字符数组没有。所以此处需要注意：因为src要求有null结束符，所以字符数组的长度必须大于等于src包含null结束符的总长度。例如，char* src=”abcd”; char dest[5]; 这里dest的长度就至少为5。</p>
<ol>
<li>strncpy函数：多个n代表可以指定字符个数进行赋值。原型：char <em> strncpy(char </em>dest, char <em>src, size_t n);  功能：将字符串src中最多n个字符复制到字符数组dest中(它并不像strcpy一样遇到NULL才停止复制，而是等凑够n个字符才开始复制），返回指向dest的指针。要求：如果n &gt; dest串长度，dest栈空间溢出产生崩溃异常。该函数注意的地方和strcpy类似，但是n值需特别注意，<br>1）src串长度&lt;=dest串长度,(这里的串长度包含串尾NULL字符)<br>如果n=(0, src串长度)，src的前n个字符复制到dest中。但是由于没有NULL字符，所以直接访问dest串会发生栈溢出的异常情况。这时，一般建议采取memset将dest的全部元素用null填充，如：memset(dest,0,7)（7为从dest起始地址开始前7个位置填充null，dest可以为字符指针和数组名）。注意：char</em> pc=”abc”; char chs[5]; sizeof(pc)为4（包含null）(有些编译器不行），sizeof(chs)为5。<br>如果n = src串长度，与strcpy一致。<br>如果n = dest串长度，[0,src串长度]处存放于desk字串，(src串长度, dest串长度]处存放NULL。<br>2）src串长度&gt;dest串长度<br>如果n =dest串长度，则dest串没有NULL字符，会导致输出会有乱码。如果不考虑src串复制完整性，可以将dest最后一字符置为NULL。<br>所以，一般把n设为dest（含null）的长度（除非将多个src复制到dest中）。当2）中n=dest串长度时，定义dest为字符数组，因为这时没有null字符拷贝。</li>
</ol>
<p>3、memcpy函数<br>void  <em>memcpy(void </em>s1,  const void *s2,  size_t  n);<br>说明：<br>函数memcpy从s2指向的对象中复制n个字符到s1指向的对象中。如果复制发生在两个重叠的对象中，则这种行为未定义。<br>返回值：<br>函数memcpy返回s1的值。</p>
<p>memcpy用来在内存中复制数据，由于字符串是以“\0”结尾的，所以对于在数据中包含“\0”的数据只能用memcpy。<br>Strncpy和memcpy很相似，只不过它在一个终止的空字符处停止。当n&gt;strlen(s1)时，给s2不够数的空间里填充“\0”；当n&lt;=strlen(s1)时，s2是没有结束符“\0”的。</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/05/29/the-road-to-learn-of-android-start/" itemprop="url">
                Android取经之路--学习启动篇
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-05-29T09:04:14+08:00" content="2016-05-29">
            2016-05-29
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Android取经之路/" itemprop="url" rel="index">
                  <span itemprop="name">Android取经之路</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/05/29/the-road-to-learn-of-android-start/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/29/the-road-to-learn-of-android-start/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>&nbsp;&nbsp;&nbsp;&nbsp;现如今，几乎人手一台手机，据统计，平均每人每天花在手机上的时间达到了3-4小时，现在主流的支柱型手机系统是Android、IOS。<br>&nbsp;&nbsp;&nbsp;&nbsp;根据Gartner去年第四季的调查，Android于智慧型手机市场的占有率为80.7%，排名第二的苹果iOS则是17.7%。在过去的一年全球推出了超过600款Android手机，程序安装数量已经突破了650亿。在今年5月份谷歌开发者大会上，Android系统发布了Android7.0-Android N，Android也向前迭代了几十个版本。<br>&nbsp;&nbsp;&nbsp;&nbsp;既然Android那么流行，那么到底他是如何工作的，他的内部构造是什么，很值得我们深入研究学习。最近也看了老罗-罗升阳的Android之旅，老罗不愧为大神级人物，每个模块讲解的都很深入，但是其中都是基于Android2.2，与现在的版本已经差了好几个大版本，现在最常用也最稳定的版本是Android6.0-Android M，因此接下来我会参考老罗的相关文章以及其他网络大神的相关文章，基于Android6.0的源码进行展开学习。</p>
<p>准备学习分享的内容从以下几个方面进行：<br>语法：<br>C语言：<br> 入门书籍：《The C ProGramming Language》<br> 进阶书籍：《C与指针》<br> 参考我的博客:<a href="http://tianger.github.io/categories/C%E4%B8%8E%E6%8C%87%E9%92%88/">《C与指针》</a></p>
<p>JAVA语言：<br> 入门书籍：《Head first java》<br> 进阶书籍：《thinking in java》</p>
<p>C++语言：<br>  建议书籍：《C++ primer》</p>
<p>MakeFile:<br> 入门书籍：《跟我一起写Makefile》</p>
<p>Python：<br> 入门书籍：<br> 参考我的博客:<a href="http://tianger.github.io/categories/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99python/">《跟我一起写Python》</a></p>
<p>Android系统源码学习：<br>1.环境搭建及编译<br>2.APP到Kernel通路学习<br>   (1)内核中编写硬件驱动<br>   (2)C空间增加可执行程序访问硬件驱动<br>   (3)HAL层(硬件抽象层)访问Linux内核驱动程序<br>   (4)HAL层写JNI方法提供Framework使用<br>   (5)Framework提供接口访问硬件<br>   (6)JAVA层APP通过Framework接口访问Kernel层驱动</p>
<p>3.Android系统启动<br>  1)init<br>  2)Zygote<br>  3)SystemServer</p>
<p>4.Android通信方式</p>
<p>5.Binder层学习</p>
<p>6.Socket学习<br>   (1)基础socket<br>   (2)LocalSocket<br>   (3)AIDL机制<br>   (4)JAVA空间到C空间Socket通信流程</p>
<p>7.Handler</p>
<p>8.四大组件<br>  (1)Activity<br>  (2)Brodcast<br>  (3)Service<br>  (4)Content Provider</p>
<p>9.多线程，进程通讯</p>
<p>10.同步异步机制</p>
<p>11.RIL(Radio Interface Layer 无线接口)层分析</p>
<p>12.Telephony层分析</p>
<p>13.通话过程分析</p>
<p>14.selinux<br>15.ART虚拟机<br>16.设计模式<br>     1)单例<br>     2反射机制<br>     3)工程模式<br>       …<br>   虽然一直在通信行业，但是一直从事的都是高通Modem 协议、平台的分析与开发，Android的开发比较少，了解也比较少。<br>   为了不落伍，接下来准备先花一个半月的时间回顾一下《C与指针》、《Thinking in java》、《C++ primer》，同时，会把相关的疑问以及期间的隐藏问题列举出来，单独进行分析。<br>   然后计划花费大半年到一年的时间，根据上述的Android系统源码学习的过程进行一系列的文章描述。</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xn24x.com1.z0.glb.clouddn.com/headphoto.png" alt="Tianger Ge" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Tianger Ge</p>
        </div>
        <p class="site-description motion-element" itemprop="description">3G/LTE protocol | C</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">46</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tianger Ge</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tianger"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
