<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="3G/LTE protocol | C" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="3G/LTE protocol | C">
<meta property="og:type" content="website">
<meta property="og:title" content="Tianger's Family">
<meta property="og:url" content="http://tianger.github.io/index.html">
<meta property="og:site_name" content="Tianger's Family">
<meta property="og:description" content="3G/LTE protocol | C">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tianger's Family">
<meta name="twitter:description" content="3G/LTE protocol | C">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Tianger's Family </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3000033e6d5b1f1f2b431451efbce4ef";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Tianger's Family</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/30/the-road-to-learn-of-android-kernel-start/" itemprop="url">
                在Android内核中编写硬件驱动
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-30T18:28:01+08:00" content="2016-07-30">
            2016-07-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Android取经之路/" itemprop="url" rel="index">
                  <span itemprop="name">Android取经之路</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/30/the-road-to-learn-of-android-kernel-start/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/30/the-road-to-learn-of-android-kernel-start/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本章主要讲解在Android的内核中编译硬件驱动程序，由于没有明确的GPIO口控制，因此这里不涉及硬件部分，我们使用一个虚拟硬件设备，并实现读写接口。</p>
<p>由于我现在内核的知识点还比较浅，因此内核的部分只是作为参考，主要目的，是为了尝试从APK到内核的一条通路实现过程。详细的内核需要等以后把Framework相关的知识补充完整后，再进一步学习。</p>
<p>这里创建一个虚拟硬件设备，命名为hello，即内核驱动的名称也为hello，用来进行读写寄存器的值。</p>
<h3 id="1-进入到kernel/driers，并新建hello文件夹">1.进入到kernel/driers，并新建hello文件夹</h3><blockquote>
<p>Tianger:~ getianger$ cd /Developer/Android/kernel/drivers/<br>Tianger:drivers getianger$ mkdir hello</p>
</blockquote>
<h3 id="2-进入到hello目录，并创建hello-h,在hello-h中编写如下代码：">2.进入到hello目录，并创建hello.h,在hello.h中编写如下代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> _HELLO_ANDROID_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _HELLO_ANDROID_H_</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> HELLO_DEVICE_NODE_NAME  <span class="string">"hello"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> HELLO_DEVICE_FILE_NAME  <span class="string">"hello"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> HELLO_DEVICE_PROC_NAME  <span class="string">"hello"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> HELLO_DEVICE_CLASS_NAME <span class="string">"hello"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符设备结构体*/</span></span><br><span class="line"><span class="keyword">struct</span> hello_android_dev &#123;</span><br><span class="line">    <span class="keyword">int</span> val;                            <span class="comment">//设备寄存器</span></span><br><span class="line">    <span class="keyword">struct</span> semaphore sem; <span class="comment">//信号量，用于同步访问寄存器val</span></span><br><span class="line">    <span class="keyword">struct</span> cdev dev;            <span class="comment">//字符设备</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里定义了四个名称，分别为设备节点名称、设备文件名—通过传统的设备文件来访问、设备proc文件名–通过proc文件系统来访问、设备目录名称，这里都称为hello.<br> 同时创建了一个字符设备结构体，包括val-设备寄存器；sem—信号量，用于同步访问寄存器val，dev—字符设备。</p>
<h3 id="3-在hello目录中创建hello-c，用来实现驱动程序-">3.在hello目录中创建hello.c，用来实现驱动程序.</h3><p>这里主要是为了向上层提供寄存器的读写接口，便于进行寄存器值得读与写。我们常用的读写设备方法是传统的设备访问方法—open、release、read、write这四个打开、释放、读取、写入文件的方法，这里我们还要提供另外两种方法，一种是通过proc文件系统来访问，另一种是通过devfs文件系统来访问。下面进入正题。</p>
<p>先定义三种设备的访问方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*主设备和从设备号变量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> hello_major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> hello_minor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备类别和设备变量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">class</span>* hello_class = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> hello_android_dev* hello_dev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.传统的设备文件操作方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_open</span><span class="params">(<span class="keyword">struct</span> inode* inode, <span class="keyword">struct</span> file* filp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_release</span><span class="params">(<span class="keyword">struct</span> inode* inode, <span class="keyword">struct</span> file* filp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">hello_read</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="keyword">char</span> __user *buf, size_t count, loff_t* f_pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">hello_write</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, size_t count, loff_t* f_pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.devfs文件系统访问--设备文件操作方法表*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> file_operations hello_fops = &#123;</span><br><span class="line">  .owner = THIS_MODULE,</span><br><span class="line">  .open = hello_open,</span><br><span class="line">  .release = hello_release,</span><br><span class="line">  .read = hello_read,</span><br><span class="line">  .write = hello_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.devfs文件系统访问--访问设置属性方法-*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">hello_val_show</span><span class="params">(<span class="keyword">struct</span> device* dev, <span class="keyword">struct</span> device_attribute* attr,  <span class="keyword">char</span>* buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">hello_val_store</span><span class="params">(<span class="keyword">struct</span> device* dev, <span class="keyword">struct</span> device_attribute* attr, <span class="keyword">const</span> <span class="keyword">char</span>* buf, size_t count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义设备属性*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(val, S_IRUGO | S_IWUSR, hello_val_show, hello_val_store)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.Proc文件系统访问操作方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">hello_proc_read</span><span class="params">(<span class="keyword">char</span>* page, <span class="keyword">char</span>** start, off_t off, <span class="keyword">int</span> count, <span class="keyword">int</span>* eof, <span class="keyword">void</span>* data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">hello_proc_write</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buff, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span>* data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_create_proc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_remove_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="1)接下来开始先使用第一种访问方法—传统的设备文件访问方法。">1)接下来开始先使用第一种访问方法—传统的设备文件访问方法。</h4><p>通过hello_open \ hello_release \ hello_read \ hello_write 来进行文件的打开、释放、读取、写入操作。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span>   1.传统设备访问方法                       <span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>打开设备方法<span class="keyword">*</span>/</span><br><span class="line">static int hello_open(struct inode<span class="keyword">*</span> inode, struct file<span class="keyword">*</span> filp) &#123;</span><br><span class="line">  struct hello_android_dev<span class="keyword">*</span> dev;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>将自定义设备结构体保存在文件指针的私有数据域中，以便访问设备时拿来用<span class="keyword">*</span>/</span><br><span class="line">  dev = container_of(inode-&gt;i_cdev, struct hello_android_dev, dev);</span><br><span class="line">  filp-&gt;private_data = dev;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>设备文件释放时调用，我们这里使用虚拟是被，因此无需真正实发，只要返回空即可<span class="keyword">*</span>/</span><br><span class="line">static int hello_release(struct inode<span class="keyword">*</span> inode, struct file<span class="keyword">*</span> filp) &#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>读取设备的寄存器val的值<span class="keyword">*</span>/</span><br><span class="line">static ssize_t hello_read(struct file<span class="keyword">*</span> filp, char __user <span class="keyword">*</span>buf, size_t count, loff_t<span class="keyword">*</span> f_pos) &#123;</span><br><span class="line">  ssize_t err = 0;</span><br><span class="line">  struct hello_android_dev<span class="keyword">*</span> dev = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>同步访问<span class="keyword">*</span>/</span><br><span class="line">  /<span class="keyword">*</span>用来获取信号量，如果信号量大于或等于0，获取信号量，否则进入睡眠状态，等待信号量被释放后，激活该程<span class="keyword">*</span>/</span><br><span class="line">  if(down_interruptible(&amp;(dev-&gt;sem))) &#123;</span><br><span class="line">    return -ERESTARTSYS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(count <span class="variable">&lt; sizeof(dev-&gt;</span>val)) &#123;</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>将寄存器val的值拷贝到用户提供的缓冲区<span class="keyword">*</span>/</span><br><span class="line">  /<span class="keyword">*</span>从内核空间读取val数值到用户空间<span class="keyword">*</span>/</span><br><span class="line">  if(copy_to_user(buf, &amp;(dev-&gt;val), sizeof(dev-&gt;val))) &#123;</span><br><span class="line">    err = -EFAULT;</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = sizeof(dev-&gt;val);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  /<span class="keyword">*</span>释放信号量<span class="keyword">*</span>/</span><br><span class="line">  up(&amp;(dev-&gt;sem));</span><br><span class="line">  return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>写设备的寄存器值val<span class="keyword">*</span>/</span><br><span class="line">static ssize_t hello_write(struct file<span class="keyword">*</span> filp, const char __user <span class="keyword">*</span>buf, size_t count, loff_t<span class="keyword">*</span> f_pos) &#123;</span><br><span class="line">  struct hello_android_dev<span class="keyword">*</span> dev = filp-&gt;private_data;</span><br><span class="line">  ssize_t err = 0;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>同步访问<span class="keyword">*</span>/</span><br><span class="line">  if(down_interruptible(&amp;(dev-&gt;sem))) &#123;</span><br><span class="line">    return -ERESTARTSYS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(count != sizeof(dev-&gt;val)) &#123;</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>将用户提供的缓冲区的值写到设备寄存器去<span class="keyword">*</span>/</span><br><span class="line">  /<span class="keyword">*</span>将用户空间的数据val，写入到内核空间中<span class="keyword">*</span>/</span><br><span class="line">  if(copy_from_user(&amp;(dev-&gt;val), buf, count)) &#123;</span><br><span class="line">    err = -EFAULT;</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = sizeof(dev-&gt;val);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  /<span class="keyword">*</span>释放信号量<span class="keyword">*</span>/</span><br><span class="line">  up(&amp;(dev-&gt;sem));</span><br><span class="line">  return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2)通过devfs文件系统访问方法">2)通过devfs文件系统访问方法</h4><p>这里把设备的寄存器val看成是设备的一个属性，通过读写这个属性来对设备进行访问，主要是实现hello_val_show和hello_val_store两个方法，同时定义了两个内部使用的访问val值的方法<strong>hello_get_val和</strong>hello_set_val：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span>   2.devfs文件系统访问方法                  <span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span>读取寄存器val的值到缓冲区buf中，内部使用<span class="keyword">*</span>/</span><br><span class="line">static ssize_t __hello_get_val(struct hello_android_dev<span class="keyword">*</span> dev, char<span class="keyword">*</span> buf) &#123;</span><br><span class="line">  int val = 0;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>同步访问<span class="keyword">*</span>/</span><br><span class="line">  if(down_interruptible(&amp;(dev-&gt;sem))) &#123;</span><br><span class="line">    return -ERESTARTSYS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val = dev-&gt;val;</span><br><span class="line">  /<span class="keyword">*</span>释放信号量<span class="keyword">*</span>/</span><br><span class="line">  up(&amp;(dev-&gt;sem));</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>把val的值写入到buf中<span class="keyword">*</span>/</span><br><span class="line">  return snprintf(buf, PAGE_SIZE, <span class="string">"%d\n"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>把缓冲区buf的值写到设备寄存器val中去，内部使用<span class="keyword">*</span>/</span><br><span class="line">static ssize_t __hello_set_val(struct hello_android_dev<span class="keyword">*</span> dev, const char<span class="keyword">*</span> buf, size_t count) &#123;</span><br><span class="line">  int val = 0;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>将字符串转换成数字<span class="keyword">*</span>/</span><br><span class="line">  val = simple_strtol(buf, NULL, 10);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>同步访问<span class="keyword">*</span>/</span><br><span class="line">  if(down_interruptible(&amp;(dev-&gt;sem))) &#123;</span><br><span class="line">    return -ERESTARTSYS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>把需要写入的val的值，传入到dev-&gt;val中<span class="keyword">*</span>/</span><br><span class="line">  dev-&gt;val = val;</span><br><span class="line">  up(&amp;(dev-&gt;sem));</span><br><span class="line"></span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>读取设备属性val<span class="keyword">*</span>/</span><br><span class="line">static ssize_t hello_val_show(struct device<span class="keyword">*</span> dev, struct device_attribute<span class="keyword">*</span> attr, char<span class="keyword">*</span> buf) &#123;</span><br><span class="line">  struct hello_android_dev<span class="keyword">*</span> hdev = (struct hello_android_dev<span class="keyword">*</span>)dev_get_drvdata(dev);</span><br><span class="line"></span><br><span class="line">  return __hello_get_val(hdev, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>写设备属性val<span class="keyword">*</span>/</span><br><span class="line">static ssize_t hello_val_store(struct device<span class="keyword">*</span> dev, struct device_attribute<span class="keyword">*</span> attr, const char<span class="keyword">*</span> buf, size_t count) &#123;</span><br><span class="line">  struct hello_android_dev<span class="keyword">*</span> hdev = (struct hello_android_dev<span class="keyword">*</span>)dev_get_drvdata(dev);</span><br><span class="line"></span><br><span class="line">  return __hello_set_val(hdev, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3)通过proc文件系统访问方法">3)通过proc文件系统访问方法</h4><p>主要实现了hello_proc_read和hello_proc_write两个方法，同时定义了在proc文件系统创建和删除文件的方法hello_create_proc和hello_remove_proc：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span>   3.proc文件系统访问方法                   <span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>读取设备寄存器val的值，保存在page缓冲区中<span class="keyword">*</span>/</span><br><span class="line">static ssize_t hello_proc_read(char<span class="keyword">*</span> page, char<span class="keyword">*</span><span class="keyword">*</span> start, off_t off, int count, int<span class="keyword">*</span> eof, void<span class="keyword">*</span> data) &#123;</span><br><span class="line">  if(off &gt; 0) &#123;</span><br><span class="line">    <span class="keyword">*</span>eof = 1;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return __hello_get_val(hello_dev, page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>把缓冲区的值buff保存到设备寄存器val中去<span class="keyword">*</span>/</span><br><span class="line">static ssize_t hello_proc_write(struct file<span class="keyword">*</span> filp, const char __user <span class="keyword">*</span>buff, unsigned long len, void<span class="keyword">*</span> data) &#123;</span><br><span class="line">  int err = 0;</span><br><span class="line">  char<span class="keyword">*</span> page = NULL;</span><br><span class="line"></span><br><span class="line">  if(len &gt; PAGE_SIZE) &#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">"The buff is too large: %lu.\n"</span>, len);</span><br><span class="line">    return -EFAULT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  page = (char<span class="keyword">*</span>)__get_free_page(GFP_KERNEL);</span><br><span class="line">  if(!page) &#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">"Failed to alloc page.\n"</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>先把用户提供的缓冲区值拷贝到内核缓冲区中去<span class="keyword">*</span>/</span><br><span class="line">  if(copy_from_user(page, buff, len)) &#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">"Failed to copy buff from user.\n"</span>);</span><br><span class="line">    err = -EFAULT;</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = __hello_set_val(hello_dev, page, len);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  free_page((unsigned long)page);</span><br><span class="line">  return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>创建/proc/hello文件<span class="keyword">*</span>/</span><br><span class="line">static void hello_create_proc(void) &#123;</span><br><span class="line">  struct proc_dir_entry<span class="keyword">*</span> entry;</span><br><span class="line"></span><br><span class="line">  entry = create_proc_entry(HELLO_DEVICE_PROC_NAME, 0, NULL);</span><br><span class="line">  if(entry) &#123;</span><br><span class="line">    entry-&gt;owner = THIS_MODULE;</span><br><span class="line">    entry-&gt;read_proc = hello_proc_read;</span><br><span class="line">    entry-&gt;write_proc = hello_proc_write;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>删除/proc/hello文件<span class="keyword">*</span>/</span><br><span class="line">static void hello_remove_proc(void) &#123;</span><br><span class="line">  remove_proc_entry(HELLO_DEVICE_PROC_NAME, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4)最后，实现模块加载和卸载方法，这里只要是执行设备注册和初始化操作：">4)最后，实现模块加载和卸载方法，这里只要是执行设备注册和初始化操作：</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span>   设备注册和初始化操作                      <span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>初始化设备<span class="keyword">*</span>/</span><br><span class="line">static int  __hello_setup_dev(struct hello_android_dev<span class="keyword">*</span> dev) &#123;</span><br><span class="line">  int err;</span><br><span class="line">  /<span class="keyword">*</span>将主设备号和次设备号转换成dev_t类型<span class="keyword">*</span>/</span><br><span class="line">  dev_t devno = MKDEV(hello_major, hello_minor);</span><br><span class="line"></span><br><span class="line">  memset(dev, 0, sizeof(struct hello_android_dev));</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>静态初始化dev设备<span class="keyword">*</span>/</span><br><span class="line">  cdev_init(&amp;(dev-&gt;dev), &amp;hello_fops);</span><br><span class="line">  dev-&gt;dev.owner = THIS_MODULE;</span><br><span class="line">  dev-&gt;dev.ops = &amp;hello_fops;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>注册字符设备<span class="keyword">*</span>/</span><br><span class="line">  err = cdev_add(&amp;(dev-&gt;dev),devno, 1);</span><br><span class="line">  if(err) &#123;</span><br><span class="line">    return err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>初始化信号量和寄存器val的值<span class="keyword">*</span>/</span><br><span class="line">  init_MUTEX(&amp;(dev-&gt;sem));</span><br><span class="line">  /<span class="keyword">*</span>初始信号量值为0<span class="keyword">*</span>/</span><br><span class="line">  dev-&gt;val = 0;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>模块加载方法<span class="keyword">*</span>/</span><br><span class="line">static int __init hello_init(void)&#123;</span><br><span class="line">  int err = -1;</span><br><span class="line">  dev_t dev = 0;</span><br><span class="line">  struct device<span class="keyword">*</span> temp = NULL;</span><br><span class="line"></span><br><span class="line">  printk(KERN_ALERT<span class="string">"Initializing hello device.\n"</span>);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>动态分配主设备和从设备号<span class="keyword">*</span>/</span><br><span class="line">  err = alloc_chrdev_region(&amp;dev, 0, 1, HELLO_DEVICE_NODE_NAME);</span><br><span class="line">  if(err <span class="variable">&lt; 0) &#123;</span><br><span class="line">    printk(KERN_ALERT"Failed to alloc char dev region.\n");</span><br><span class="line">    goto fail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hello_major = MAJOR(dev);</span><br><span class="line">  hello_minor = MINOR(dev);</span><br><span class="line"></span><br><span class="line">  /*分配helo设备结构体变量*/</span><br><span class="line">  hello_dev = kmalloc(sizeof(struct hello_android_dev), GFP_KERNEL);</span><br><span class="line">  if(!hello_dev) &#123;</span><br><span class="line">    err = -ENOMEM;</span><br><span class="line">    printk(KERN_ALERT"Failed to alloc hello_dev.\n");</span><br><span class="line">    goto unregister;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*初始化设备*/</span><br><span class="line">  err = __hello_setup_dev(hello_dev);</span><br><span class="line">  if(err) &#123;</span><br><span class="line">    printk(KERN_ALERT"Failed to setup dev: %d.\n", err);</span><br><span class="line">    goto cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*在/sys/class/目录下创建设备类别目录hello*/</span><br><span class="line">  hello_class = class_create(THIS_MODULE, HELLO_DEVICE_CLASS_NAME);</span><br><span class="line">  if(IS_ERR(hello_class)) &#123;</span><br><span class="line">    err = PTR_ERR(hello_class);</span><br><span class="line">    printk(KERN_ALERT"Failed to create hello class.\n");</span><br><span class="line">    goto destroy_cdev;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*在/dev/目录和/sys/class/hello目录下分别创建设备文件hello*/</span><br><span class="line">  temp = device_create(hello_class, NULL, dev, "%s", HELLO_DEVICE_FILE_NAME);</span><br><span class="line">  if(IS_ERR(temp)) &#123;</span><br><span class="line">    err = PTR_ERR(temp);</span><br><span class="line">    printk(KERN_ALERT"Failed to create hello device.");</span><br><span class="line">    goto destroy_class;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*在/sys/class/hello/hello目录下创建属性文件val*/</span><br><span class="line">  err = device_create_file(temp, &amp;dev_attr_val);</span><br><span class="line">  if(err &lt; 0) &#123;</span><br><span class="line">    printk(KERN_ALERT"Failed to create attribute val.");</span><br><span class="line">    goto destroy_device;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dev_set_drvdata(temp, hello_dev);</span><br><span class="line"></span><br><span class="line">  /*创建/proc/hello文件*/</span><br><span class="line">  hello_create_proc();</span><br><span class="line"></span><br><span class="line">  printk(KERN_ALERT"Succedded to initialize hello device.\n");</span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">destroy_device:</span><br><span class="line">  device_destroy(hello_class, dev);</span><br><span class="line"></span><br><span class="line">destroy_class:</span><br><span class="line">  class_destroy(hello_class);</span><br><span class="line"></span><br><span class="line">destroy_cdev:</span><br><span class="line">  cdev_del(&amp;(hello_dev-&gt;</span>dev));</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">  kfree(hello_dev);</span><br><span class="line"></span><br><span class="line">unregister:</span><br><span class="line">  unregister_chrdev_region(MKDEV(hello_major, hello_minor), 1);</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span>模块卸载方法<span class="keyword">*</span>/</span><br><span class="line">static void __exit hello_exit(void) &#123;</span><br><span class="line">  dev_t devno = MKDEV(hello_major, hello_minor);</span><br><span class="line"></span><br><span class="line">  printk(KERN_ALERT<span class="string">"Destroy hello device.\n"</span>);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>删除/proc/hello文件<span class="keyword">*</span>/</span><br><span class="line">  hello_remove_proc();</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>销毁设备类别和设备<span class="keyword">*</span>/</span><br><span class="line">  if(hello_class) &#123;</span><br><span class="line">    device_destroy(hello_class, MKDEV(hello_major, hello_minor));</span><br><span class="line">    class_destroy(hello_class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>删除字符设备和释放设备内存<span class="keyword">*</span>/</span><br><span class="line">  if(hello_dev) &#123;</span><br><span class="line">    cdev_del(&amp;(hello_dev-&gt;dev));</span><br><span class="line">    kfree(hello_dev);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span>释放设备号<span class="keyword">*</span>/</span><br><span class="line">  unregister_chrdev_region(devno, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"First Android Driver"</span>);</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure>
<h3 id="4-驱动程序写完成了，接下来我们进入到编译的流程:">4.驱动程序写完成了，接下来我们进入到编译的流程:</h3><blockquote>
<p>1)在hello目录中新建两个文件Kconfig\Makefile</p>
<p>2)在Makefile中假如下列两行<br>    obj-$(CONFIG_HELLO) += hello.o<br>    obj-$(CONFIG_HELLO) += hello/</p>
<p>3)kernel/drivers目录和目录kernel\arch\arm中修改Kconfig<br>     在menu “Device Drivers”和endmenu之间添加一行：<br>     source “drivers/hello/Kconfig”</p>
<p>4)修改arch/arm/Kconfig<br>         在menu “Device Drivers”和endmenu之间添加一行：<br>          source “drivers/hello/Kconfig”</p>
<p>5)进入到kernel目录中，输入命令make menuconfig<br>     在弹出的界面中选择”Device Drivers”，进入到二级界面，选择”First Android Drivers”，输入y，并选择save，现在exit，一直退出menuconfig的界面</p>
<p>6)cd kernel目录，输入make进行编译</p>
</blockquote>
<p>编译成功后，我们可以在hello目录中看到我们的hello.o文件，并且产生的image中已经包含了hello驱动，把这个image下载到手机或者使用模拟器打开这个image就可以进行验证，至此，我们的hello驱动程序编写完成。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/17/the-road-to-learn-of-android-hal/" itemprop="url">
                Android硬件抽象层(HAL层)学习计划
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-17T18:31:15+08:00" content="2016-07-17">
            2016-07-17
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Android取经之路/" itemprop="url" rel="index">
                  <span itemprop="name">Android取经之路</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/17/the-road-to-learn-of-android-hal/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/17/the-road-to-learn-of-android-hal/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Android的系统非常复杂和庞大，底层以Linux为基础，上层采用带有虚拟机的JAVA层，通过JNI技术，将上下层打通。我们通常在网上看到的都是官方给出的经典四层架构图。从上到下分别是应用程序层、应用框架层、系统库和运行时库，Linux内核。但是我这里给出的图示多了一层为HAL层(硬件抽象层)，这一层主要作用是对硬件设备的具体实现加以抽象.<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/Android-5%E5%B1%82.png" alt=""></p>
   <center>图1 Android 5层架构图</center>

<p>Android启动图示：<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/Android-poweron.png" alt=""></p>
<center>图2：Android开机启动流程</center>

<blockquote>
<p>第一步：手机开机后，引导芯片启动，引导程序到RAM，bootloader检查RAM，初始化硬件等参数</p>
<p>第二步：硬件等参数初始化完成后，进入到Kernel层，Kernel层主要加载一些硬件设备驱动，初始化进程管理等操作</p>
<p>第三步：Kernel层加载完毕后，硬件设备驱动与HAL层进行交互。初始化进程管理等操作会启动INIT进程 ，这些在Native层中</p>
<p>第四步：init进程(是所有进程的鼻祖，第一个启动)启动后，会启动adbd，logd等用户守护进程，并且会启动service Manager等重要服务，同时记载zygote进程，这里属于C++ Framework，代码为C++程序</p>
<p>第五步：zygote是init进程解析init.rc文件后fork生成，它会加载虚拟机，启动System Server；System Server负责启动和管理整个Java sFramework</p>
<p>第六步：zygote同时会启动相关的APP进程，它启动的第一个APP进程为Launcher，然后启动Email，SMS等进程，所有的APP进程都有zygote fork生成。</p>
</blockquote>
<p>至此，Android系统加载完成。</p>
<p>接下来将根据图2的Android开机启动流程，一步步的进行分析和学习，Bootloader本段学习过程不做描述，这涉及到各个设备厂商的相关核心代码。所以我接下来会从Kernel一步步的往上分析，但是由于Kernel的技术内容太多，涉及面很广，因此深入阐述的地方还要待以后进一步挖掘。</p>
<p>  下面先开始硬件抽象层(HAL层)的学习，部分知识点参考了老罗(罗升阳)的技术博客。</p>
<p>   我们先想一下为什么要有Android硬件抽象层，我们直接从Kernel提供内核代码给libraries使用不也可以吗？Linux内核源码版权需要遵循GNU License，在产品发布时，需要公布源码，而Android源码遵循Apache License，无需公布源码，为么不损害设备厂商的利益，Android设计出了HAL层，把对硬件的支持抽象成为 硬件抽象层和内核驱动层，内核驱动层只提供简单的访问逻辑，具体的实现都放在硬件抽象层中来实现。<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/HAL.png" alt=""></p>
<center>图3 硬件抽象层</center>

<p>俗话说，站在巨人的肩膀上，看的更远，因此我参考老罗的之前的学习内容，也把HAL层的学习计划做了相应的调整,细节如下：</p>
<blockquote>
<p>(1)在Android内核中编写驱动<br>(2)C空间增加可执行程序访问硬件驱动<br>(3)HAL层访问Linux内核驱动程序<br>(4)HAL层写JNI方法提供Framwok访问接口<br>(5)Framework提供访问接口访问硬件<br>(6)JAVA层APP通过Framework接口访问硬件服务</p>
</blockquote>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/10/the-road-to-learn-of-android-environment/" itemprop="url">
                Android6.0 系统源码下载及环境搭建
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-10T19:28:02+08:00" content="2016-07-10">
            2016-07-10
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Android取经之路/" itemprop="url" rel="index">
                  <span itemprop="name">Android取经之路</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/10/the-road-to-learn-of-android-environment/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/10/the-road-to-learn-of-android-environment/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>前段时间回顾了一下C和JAVA的一些基础和进阶书籍，接下来让我们真正进入Android系统源码的怀抱吧，我会根据一个月之前写的<a href="http://tianger.github.io/2016/05/29/the-road-to-learn-of-android-start/">《Android取经之路–学习启动篇》</a>的知识点一步步的往下进行分析及学习，最终的目的是希望完成一个中间件，能够完成其他service到Framework，最终能到Modem的相关操作。</p>
<p>我使用的环境为Windows + Ubuntu16.04虚拟机.</p>
<p>源码下载及环境搭建参考了 AOSP - 清华大学TUNA 镜像源<br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</a></p>
<p>环境搭建—(在Ubuntu中搭建)：</p>
<h2 id="1-安装JDK1-7并完成配置：">1.安装JDK1.7并完成配置：</h2><p>在www.java.com中 下载jdk-7u79-linux-x64.tar.gz —这个根据个人的电脑配置来</p>
<p>环境变量配置方法：新建文件夹-解压-设置环境变量-测试环境变量</p>
<h3 id="1）解压JDK">1）解压JDK</h3><p>新建文件夹-解压<br>sudo mkdir /usr/lib/jvm<br>sudo tar zxvf jdk-7u79-linux-x64.tar.gz -C /usr/lib/jvm</p>
<h3 id="2）设置环境变量">2）设置环境变量</h3><p>sudo gedit /etc/profile</p>
<h3 id="3）加入环境变量内容">3）加入环境变量内容</h3><p>export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_79<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>
<h3 id="4）设置默认的JDK">4）设置默认的JDK</h3><p>sudo update-alternatives –install /usr/bin/java java /usr/lib/jvm/jdk1.7.0_79/bin/java 300<br>sudo update-alternatives –install /usr/bin/javac javac /usr/lib/jvm/jdk1.7.0_79/bin/javac 300</p>
<h3 id="5）重启一下/efc/profile">5）重启一下/efc/profile</h3><p>source  /efc/profile</p>
<h3 id="6）测试">6）测试</h3><p>java -version</p>
<h3 id="7）显示JDK版本则配置成功">7）显示JDK版本则配置成功</h3><p>root@ubuntu:/home/ubuntu/Public# java -version<br>java version “1.7.0_79”<br>Java(TM) SE Runtime Environment (build 1.7.0_79-b15)<br>Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</p>
<h2 id="2-安装_git">2.安装 git</h2><p>sudo apt-get install git-core</p>
<h2 id="3-安装curl">3.安装curl</h2><p>sudo apt-get install git-core curl</p>
<p>4## .安装repo, 通过curl下载repo<br>mkdir ~/bin<br>PATH=~/bin:$PATH<br>curl <a href="https://storage.googleapis.com/git-repo-downloads/repo" target="_blank" rel="external">https://storage.googleapis.com/git-repo-downloads/repo</a> &gt; ~/bin/repo<br>chmod a+x ~/bin/repo</p>
<h2 id="5-新建一个目录，然后进入该目录。">5.新建一个目录，然后进入该目录。</h2><p>cd /home/tianger<br>mkdir AP6.0  //创建一个目录，这个目录用来保存源码<br>cd AP6.0</p>
<h2 id="6-版本下载：">6.版本下载：</h2><h3 id="1)初始化git仓库">1)初始化git仓库</h3><p>repo init -u <a href="https://aosp.tuna.tsinghua.edu.cn/platform/manifest" target="_blank" rel="external">https://aosp.tuna.tsinghua.edu.cn/platform/manifest</a> -b android-6.0.0_r26</p>
<p>如果提示下面错误:<br>Cannot get <a href="https://gerrit.googlesource.com/git-repo/clone.bundle" target="_blank" rel="external">https://gerrit.googlesource.com/git-repo/clone.bundle</a></p>
<p>可以修改~/bin/repo下面的REPO_URL</p>
<p>sudo gedit ~/bin/repo<br>修改REPO_URL = ‘<a href="https://gerrit-google.tuna.tsinghua.edu.cn/git-repo’" target="_blank" rel="external">https://gerrit-google.tuna.tsinghua.edu.cn/git-repo’</a></p>
<h3 id="2)下载代码">2)下载代码</h3><p>repo sync</p>
<p>基本上等上一到两晚上就能下载成功</p>
<h2 id="7-版本编译：">7.版本编译：</h2><p>先用build/envsetup.sh设置环境变量，再调用 lunch 命令选择构建目标。<br>之后即执行 make -jN 进行编译。我用的参数为 -j4 编译了大约两个小时：</p>
<h2 id="8-编译方法：">8.编译方法：</h2><p>1) source build/envsetup.sh</p>
<p>2) lunch full-eng</p>
<p>3) make -j4<br>这里的j4标示使用4个线程，可以用多个线程，根据自己CPU决定</p>
<p>4) adb reboot bootloader</p>
<p>5)fastboot flashall -w</p>
<p>6)emulator</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/26/c-and-point-seventeen-queue/" itemprop="url">
                C与指针-第十七章-队列
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-26T16:14:44+08:00" content="2016-06-26">
            2016-06-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/26/c-and-point-seventeen-queue/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/26/c-and-point-seventeen-queue/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>前面学习了堆栈的操作，本章主要来学习队列的相关操作。</p>
<h2 id="队列的特点：">队列的特点：</h2><blockquote>
<p>1)先进先出(First in First Out FIFO)<br>  例如排队等餐，先排的人拿到快餐后，离开这个队伍，后面一个人前进一位，新来的人在队伍的最后面加入<br>2)队列只允许在队首进行删除操作，队尾进行添加操作</p>
</blockquote>
<p>队列的数据存储方式主要有下面两种方式：</p>
<blockquote>
<p>1）动态数组存储<br>2）链表存储</p>
</blockquote>
<h2 id="队列的几个操作：">队列的几个操作：</h2><blockquote>
<p>1)初始化队列：<br>    队列的内容进行初始化，如果是动态申请空间队列，还需要申请空间<br> 2)进队列:<br>      数据从队尾加入<br>3)出队列:<br>      数据从队首删除<br>4)判断队列是否为空:<br>      检查队列中是否还有元素<br>5)判断队列是否已满：<br>      检查队列中元素的个数是否已达到上限</p>
</blockquote>
<p>接下来通过代码示例来实现两种存储方式的队列，为了方便操作，这里的数据都使用int类型</p>
<h2 id="1-动态数组存储">1.动态数组存储</h2><h3 id="queue-h">queue.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> QUEUE_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化并创建队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_array_queue</span><span class="params">(size_t size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destroy_array_queue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dnqueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*队首元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_top</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*队列是否为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_queue_empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*队列是否已满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_queue_full</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>###<br>queue.c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*保存数据的数组*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> *queue_arr=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*队列的实际大小*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QUEUE_SIZE    <span class="number">100</span>  <span class="comment">/*队列中元素数量的限制*/</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> true <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> false <span class="number">0</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化并创建队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_array_queue</span><span class="params">(size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    queue_arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    <span class="keyword">if</span> (queue_arr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"arr malloc error!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destroy_array_queue</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queue_arr)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">free</span>(queue_arr);</span><br><span class="line">     queue_arr = <span class="literal">NULL</span>;</span><br><span class="line">     count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  queue_arr[count++] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dnqueue</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;;</span><br><span class="line">    <span class="keyword">int</span> ret = queue_arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">while</span> (i++&lt;count)</span><br><span class="line">        queue_arr[i-<span class="number">1</span>] = queue_arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_top</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> queue_arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*队列是否为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_queue_empty</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*队列是否已满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_queue_full</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count == QUEUE_SIZE -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  init_array_queue(QUEUE_SIZE);</span><br><span class="line">  enqueue(<span class="number">10</span>);</span><br><span class="line">  enqueue(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">int</span> top = queue_top();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"queue top is %d\n"</span>,top);</span><br><span class="line">  destroy_array_queue();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-链表存储">2.链表存储</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*单链表节点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  NODE</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> NODE* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*表头*/</span></span><br><span class="line"><span class="keyword">static</span> Node *phead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建节点*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node* <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Node *pnode = <span class="literal">NULL</span>;</span><br><span class="line">    pnode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!pnode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pnode-&gt;data = data;</span><br><span class="line">    pnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁链表*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">destory_link</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Node *pnode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(phead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pnode = phead;</span><br><span class="line">        phead = phead-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!phead)</span><br><span class="line">  &#123;</span><br><span class="line">      phead = create_node(data);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node *pnode = create_node(data);</span><br><span class="line">  Node *pend = phead;</span><br><span class="line">  <span class="keyword">while</span>(pend-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">      pend = pend-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  pend-&gt;next = pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dnqueue</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> ret = phead-&gt;data;</span><br><span class="line"> Node *pnode = phead;</span><br><span class="line"> phead = phead-&gt;next;</span><br><span class="line"> <span class="built_in">free</span>(pnode);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_top</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> phead-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回链表节点个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Node *pend = phead;</span><br><span class="line">    <span class="keyword">while</span>(pend)</span><br><span class="line">    &#123;</span><br><span class="line">        pend = pend-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*队列是否为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_queue_empty</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  enqueue(<span class="number">10</span>); <span class="comment">/*入队*/</span></span><br><span class="line">  enqueue(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">int</span> top = queue_top(); <span class="comment">/*返回队首元素*/</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"queue top is %d\n"</span>,top);</span><br><span class="line">  destory_link(); <span class="comment">/*销毁队列*/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/21/c-and-point-seventeen-stack/" itemprop="url">
                C与指针-第十七章-堆栈
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-21T20:56:42+08:00" content="2016-06-21">
            2016-06-21
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/21/c-and-point-seventeen-stack/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/21/c-and-point-seventeen-stack/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>抽象数据类型(ADT)是C程序员不可或缺的工具，这类ADT有链表、堆栈、队列和树等，前面我们已经讨论过了链表，接下来我们来学习堆栈、队列和树。</p>
<p>所有的ADT都需要确定一件事情–如何获取内存来存储值，这里有三种方案：</p>
<blockquote>
<p>1)静态数组<br>2）动态内存分配<br>3）动态链表存储</p>
</blockquote>
<p>本章主要讲解堆栈的操作方式，并用上述三种方式分别来实现堆栈的操作。</p>
<blockquote>
<p>栈的特点：后进先出(Last in First out –LIFO)<br>例如向仓库里堆放货品，后放进去的靠近门口，因此也会先拿出去</p>
</blockquote>
<h3 id="栈操作：">栈操作：</h3><p>入栈(push):<br>将数据保存到栈顶的操作。进入栈操作前，先修改栈顶指针，使其向上移动一个元素位置，然后将数据保存到栈顶指针所指的位置。</p>
<p>出栈(pop)：<br>将栈顶数据弹出操作，通过修改栈顶指针，使其指向栈中的下一个元素。</p>
<h3 id="堆栈实现：">堆栈实现：</h3><h4 id="1)静态数组操作：">1)静态数组操作：</h4><p>  这一节堆栈的操作以int类型进行入栈、出栈</p>
<blockquote>
<p>stack.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> STACK_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈顶指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否为空： TRUE-栈为空; FALSE--栈不为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否已满，TRUE--栈满; FALSE--栈不满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>stack.c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_SIZE    <span class="number">100</span>  <span class="comment">/*栈中元素数量的限制*/</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> top_element = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  top_element += <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">stack</span>[top_element] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is_empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = <span class="built_in">stack</span>[top_element];</span><br><span class="line">  top_element -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈顶指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">stack</span>[top_element];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否为空： TRUE-栈为空; FALSE--栈不为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (top_element == -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否已满，TRUE--栈满; FALSE--栈不满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> top_element == STACK_SIZE -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  push(<span class="number">10</span>);</span><br><span class="line">  push(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">int</span> temp = pop();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"temp = %d\n"</span>,temp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2）动态内存分配">2）动态内存分配</h4><blockquote>
<p>stack.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> STACK_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_stack</span><span class="params">(size_t size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory_stack</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈顶指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否为空： TRUE-栈为空; FALSE--栈不为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否已满，TRUE--栈满; FALSE--栈不满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>stack.c<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include "stack.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>    *stack;</span><br><span class="line"><span class="keyword">static</span> size_t stack_size;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>    top_element = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_stack</span>(<span class="params">size_t size</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">   stack_size = size;</span><br><span class="line">   stack = malloc(stack_size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">   <span class="keyword">if</span> (stack == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      printf(<span class="string">"create_stack fail\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory_stack</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (stack_size &gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    stack_size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  free(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  top_element += <span class="number">1</span>;</span><br><span class="line">  stack[top_element] = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is_empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = stack[top_element];</span><br><span class="line">  top_element -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈顶指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> stack[top_element];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否为空： TRUE-栈为空; FALSE--栈不为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (top_element == -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否已满，TRUE--栈满; FALSE--栈不满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> top_element == stack_size -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  create_stack(<span class="number">100</span>); <span class="comment">/*创建堆栈*/</span></span><br><span class="line">  push(<span class="number">10</span>); <span class="comment">/*入栈*/</span></span><br><span class="line">  push(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">int</span> temp = pop(); <span class="comment">/*出栈*/</span></span><br><span class="line">  printf(<span class="string">"temp = %d\n"</span>,temp);</span><br><span class="line">  destory_stack(); <span class="comment">/*销毁栈*/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="3）数据链表操作：">3）数据链表操作：</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">#define</span> MAX_LEN <span class="number">100</span></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    char *top; <span class="comment">//栈顶</span></span><br><span class="line">    char *base;<span class="comment">//栈底</span></span><br><span class="line">    int stacksize;<span class="comment">//栈大小</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈的初始化*/</span></span><br><span class="line"><span class="literal">void</span> init_stack(<span class="built_in">stack</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    s<span class="subst">-&gt;</span>base = (char *)malloc(MAX_LEN * sizeof(char));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> == s)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s<span class="subst">-&gt;</span>top = s<span class="subst">-&gt;</span>base;</span><br><span class="line">    s<span class="subst">-&gt;</span>stacksize = MAX_LEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈的销毁*/</span></span><br><span class="line"><span class="literal">void</span> destory(<span class="built_in">stack</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> == s<span class="subst">-&gt;</span>base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    free(s<span class="subst">-&gt;</span>base);</span><br><span class="line">    s<span class="subst">-&gt;</span>top = s<span class="subst">-&gt;</span>base = <span class="built_in">NULL</span>;</span><br><span class="line">    s<span class="subst">-&gt;</span>stacksize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清空栈*/</span></span><br><span class="line"><span class="literal">void</span> clear(<span class="built_in">stack</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> == s<span class="subst">-&gt;</span>base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s<span class="subst">-&gt;</span>top = s<span class="subst">-&gt;</span>base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="literal">void</span> push(<span class="built_in">stack</span> *s,char elem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//s是否已满，若栈满，重新分配空间</span></span><br><span class="line">  <span class="keyword">if</span> ((s<span class="subst">-&gt;</span>top<span class="attribute">-s</span><span class="subst">-&gt;</span>base)&gt;STACK_INIT_SIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    s<span class="subst">-&gt;</span>base = (char*)realloc(s<span class="subst">-&gt;</span>base,(STACKINCRENMENT+STACK_INIT_SIZE)*sizeof(char));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> == s<span class="subst">-&gt;</span>base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将栈顶指针指向栈顶</span></span><br><span class="line">    s<span class="subst">-&gt;</span>top = s<span class="subst">-&gt;</span>base+s<span class="subst">-&gt;</span>stacksize;</span><br><span class="line">    s<span class="subst">-&gt;</span>stacksize += MAX_LEN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将元素e，写入栈顶，注意这里可能有错。</span></span><br><span class="line">   *(s<span class="subst">-&gt;</span>top)=elem;</span><br><span class="line">   s<span class="subst">-&gt;</span>top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line">char pop(<span class="built_in">stack</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//保存栈顶元素</span></span><br><span class="line">    char topelement;</span><br><span class="line">    <span class="comment">//如果栈顶指针指向与栈底指针指向同一内存单元时，表示栈为空或者栈不存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s<span class="subst">-&gt;</span>top == s<span class="subst">-&gt;</span>base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//栈顶元素= 栈的top - 1；</span></span><br><span class="line">   topelement = *(s<span class="subst">-&gt;</span>top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> topelement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MAX_LEN 100</span></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span>  *top;</span><br><span class="line">  <span class="keyword">char</span>  *tail;</span><br><span class="line">  <span class="keyword">int</span>    stacksize;</span><br><span class="line">&#125;stack;</span><br><span class="line"></span><br><span class="line">void init_stack(stack *s)</span><br><span class="line">&#123;</span><br><span class="line">  s-&gt;tail = (<span class="keyword">char</span> *)malloc(MAX_LEN*sizeof(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">NULL</span> == s)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;top = s-&gt;tail;</span><br><span class="line">  s-&gt;stacksize = MAX_LEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void destory_stack(stack *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">NULL</span> == s-&gt;tail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  free(s-&gt;tail);</span><br><span class="line">  s-&gt;top = s-&gt;tail = <span class="keyword">NULL</span>;</span><br><span class="line">  s-&gt;stacksize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear_stack(stack *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">NULL</span> == s-&gt;tail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;top = s-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(stack *s,<span class="keyword">char</span> elem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//if stack is full,need malloc new space</span></span><br><span class="line">  <span class="keyword">if</span> ((s-&gt;top - s-&gt;tail) &gt; MAX_LEN)</span><br><span class="line">  &#123;</span><br><span class="line">    s-&gt;tail = (<span class="keyword">char</span> *)malloc(MAX_LEN *sizeof(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">NULL</span> == s-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top = s-&gt;tail + s-&gt;stacksize;</span><br><span class="line">    s-&gt;stacksize += MAX_LEN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *(s-&gt;top) = elem;</span><br><span class="line">  s-&gt;top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pop(stack *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> topelem;</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;top == s-&gt;tail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  topelem = *(s-&gt;top - <span class="number">1</span>);</span><br><span class="line">  s-&gt;top--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> topelem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">  stack s;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> *elem = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//INI STACK</span></span><br><span class="line">  init_stack(&amp;s);</span><br><span class="line">  printf(<span class="string">"进栈顺序\r\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环打印elem的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*elem != <span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    push(&amp;s,*elem);</span><br><span class="line">    printf(<span class="string">"%3c\r\n"</span>,*elem);</span><br><span class="line">    elem++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出栈</span></span><br><span class="line">  printf(<span class="string">"出栈顺序\r\n"</span>);</span><br><span class="line">  <span class="keyword">while</span>((s.top != <span class="keyword">NULL</span>) &amp;&amp; (s.tail != <span class="keyword">NULL</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    printf(<span class="string">"%3c\r\n"</span>,pop(&amp;s));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear_stack(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/19/c-and-point-sixteen-stander/" itemprop="url">
                C与指针-第十六章-标准函数库
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-19T20:51:29+08:00" content="2016-06-19">
            2016-06-19
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/19/c-and-point-sixteen-stander/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/19/c-and-point-sixteen-stander/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本章主要来讲一些之前没用用过的标准函数库。分为整数函数、浮点型函数、日期和时间函数等。</p>
<h2 id="整数函数：">整数函数：</h2><p>整数函数的返回值为整型值，分为三类：算术、随机数和字符串转换。</p>
<h3 id="算术：">算术：</h3><p>标准函数库包含了4个整型算术函数—abs\labs\ div\ldiv</p>
<h4 id="abs—求绝对值:">abs—求绝对值:</h4><blockquote>
<p>原型：int abs(int value);<br>函数说明：abs用来计算传入参数的绝对值，然后将结果返回。<br>用法：<br>int answer;<br>answer = abs(-12);//answer 返回为-12的绝对值，结果为12</p>
</blockquote>
<h4 id="labs—求绝对值：">labs—求绝对值：</h4><blockquote>
<p>原型：long int labs(long int value);<br>返回值：labs跟abs一样，用来计算绝对值，但是labs支持长度为long int类型，长度更长。<br>用法：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long <span class="literal">result</span>;</span><br><span class="line">long x = -<span class="number">12345678</span>L; //长度范围超过了<span class="type">int</span>的最大范围</span><br><span class="line"><span class="literal">result</span>= labs(x);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="div—两个整数相除：">div—两个整数相除：</h4><blockquote>
<p>原型：div_t div(int numerator,int denominator);<br>返回值：返回商和余数<br>用法：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div_t q;</span><br><span class="line">q = div(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">printf("<span class="number">8</span> div <span class="number">3</span> = %d, remainder = %d\n", q.quot,q.<span class="comment">rem);</span></span><br></pre></td></tr></table></figure></p>
<p>输出：<br>8 div 3 = 3, remainder = 1</p>
</blockquote>
<h4 id="ldiv—两个整数相除：">ldiv—两个整数相除：</h4><blockquote>
<p>原型：ldiv_t ldiv(long int numer, long int denom);<br>返回值：返回商和余数<br>用法：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldiv_t lx;</span><br><span class="line">lx = ldiv(<span class="number">100000</span>L, <span class="number">30000</span>L);</span><br><span class="line">printf("<span class="number">100000</span> div <span class="number">30000</span> = %ld remainder %ld\n", lx.quot, lx.<span class="comment">rem);</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>100000 div 30000 = 3 remainder 10000</p>
</blockquote>
<h3 id="随机数：">随机数：</h3><p>在我们常用的一些加密、模拟操作的时候，需要用到随机数，这里有两个函数(rand\srand)合在一起使用能够产生伪随机数。</p>
<blockquote>
<p>伪随机数：通过计算产生随机数，有可能重复，因此不是真正的随机数。</p>
</blockquote>
<h4 id="rand—产生随机数：">rand—产生随机数：</h4><blockquote>
<p>原型：int rand():<br>用法：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>  <span class="built_in">number</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">number</span> = rand()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="srand_—提供随机数种子：">srand —提供随机数种子：</h4><blockquote>
<p>原型：void srand(unsigned int seed);<br>这里的seed是rand函数的种子，用来初始化rand()的初始值。</p>
</blockquote>
<p>rand调用之前，需要用srand产生一个种子，如果没有用主动调用srand，系统也会默认使用srand(1)。</p>
<p>通常情况下，srand后面跟时间函数来完成随机种子生成，减少随机数相同的可能性。</p>
<blockquote>
<p>srand((unsigned)time(NULL));<br>int a = rand();</p>
</blockquote>
<h3 id="字符串转换：">字符串转换：</h3><p>字符串转换函数把字符串转换成数值，常用的有atoi\atol.</p>
<h4 id="atoi—字符串转成整数：">atoi—字符串转成整数：</h4><blockquote>
<p>原型：int atoi(const char *nptr);<br>返回值：参数nptr字符串，如果第一个非空格字符存在，是数字或者正负号则开始做类型转换，之后检测到非数字(包括结束符 \0) 字符时停止转换，返回整型数。否则，返回零。</p>
</blockquote>
<p>示例：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = <span class="string">"12345.67"</span>;</span><br><span class="line">n = atoi(<span class="keyword">str</span>);  <span class="comment">//n的值为12345</span></span><br></pre></td></tr></table></figure></p>
<h4 id="atol—字符串转成长整形:">atol—字符串转成长整形:</h4><blockquote>
<p>原型：long atol(const char *nptr);<br>返回值:<br>返回转换后的长整型数。如果传入的字符串为空，或者字符串包含的内容非阿拉伯数字序列，则函数返回默认值0。</p>
</blockquote>
<p>示例：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> l;</span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = <span class="string">"98765432"</span>;</span><br><span class="line">l = atol(<span class="keyword">str</span>); <span class="comment">//l为98765432</span></span><br></pre></td></tr></table></figure></p>
<h2 id="浮点型函数：">浮点型函数：</h2><p>头文件math.h包含了函数库中剩余的数学函数的声明。这些函数的返回值以及绝大多数都是double类型。<br>常用的数学函数有三角函数、双曲线函数、对数和指数函数</p>
<h3 id="三角函数：">三角函数：</h3><blockquote>
<p>double sin(double angle);<br>double cos(double angle);<br>double tan(double angle);<br>double asin(double value);<br>double acos(double value);<br>double atan(double value);</p>
</blockquote>
<p>sin\cos和tan函数的参数是一个用弧度表示的角度，这些函数分包返回这个角度的正弦、余弦和正切值。<br>asin、acos和atan函数分别返回它们的参数的反正弦、反余弦和反正切。</p>
<h3 id="双曲线函数：">双曲线函数：</h3><blockquote>
<p>double sinh(double angle);<br>double cosh(double angle);<br>double tanh(double angle);</p>
</blockquote>
<p>这些函数分别返回它们的参数的双曲正弦、双曲余弦和双曲正切。每个函数的参数都是一个以弧度表示的角度。</p>
<h3 id="对数和指数函数：">对数和指数函数：</h3><blockquote>
<p>double exp(double x);<br>double log(double x);<br>double log10(double x);</p>
</blockquote>
<p>exp函数返回e值的x次幂<br>log函数返回x以e为第的对数，也就是常说的自然对数。log10函数返回x以10为底的对数。</p>
<h2 id="日期和时间函数：">日期和时间函数：</h2><p>日期处理函数需要引用头文件&lt; time.h&gt;</p>
<h3 id="当天时间:">当天时间:</h3><h4 id="time:">time:</h4><blockquote>
<p>原型:time_t time(time_t *returned_value);<br>返回值：如果参数是一个非NULL的指针，时间值也将通过这个指针进行存储。如果机器无法提供当前的日期和时间，或者时间值太大，无法用time_t变量表示，函数就返回-1.</p>
</blockquote>
<h4 id="ctime:">ctime:</h4><blockquote>
<p>原型:char <em>ctime(const time_t </em>timep);<br>说明：ctime将参数timep所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串返回。</p>
</blockquote>
<p>示例：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time_t timer<span class="comment">;</span></span><br><span class="line">time<span class="list">(<span class="keyword">&amp;timer</span>)</span><span class="comment">;</span></span><br><span class="line">printf<span class="list">(<span class="string">"%s\n"</span>,ctime<span class="list">(<span class="keyword">&amp;timer</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>Sun Jun 19 12:47:41 2016</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/19/c-and-point-io/" itemprop="url">
                C与指针-第十五章--输入/输出
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-19T16:20:24+08:00" content="2016-06-19">
            2016-06-19
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/19/c-and-point-io/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/19/c-and-point-io/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本章主要讨论ANSI C的输入和输出(I/O)函数。首先需要看两个错误和退出的函数。</p>
<h2 id="错误报错perror:">错误报错perror:</h2><blockquote>
<p>原型：void perror(char const *message);<br>头文件： &lt; stdio.h&gt; , &lt; stdlib.h&gt;</p>
</blockquote>
<p>如果message不是NULL，并且指向一个非空的字符串，perror函数就打印出这个字符串。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">FILE</span> *fp;</span><br><span class="line">fp = fopen(“/home/tianger/<span class="keyword">test</span>”,”r”);</span><br><span class="line"><span class="keyword">if</span>(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">     perror(“/home/tianger/<span class="keyword">test</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>/home/tianger/test：No such file or directory</p>
</blockquote>
<h2 id="终止执行exit：">终止执行exit：</h2><blockquote>
<p>原型：void exit(int status)；<br>头文件: &lt; stdlib.h&gt;</p>
</blockquote>
<p>exit,用于终止一个程序的执行，传入的status参数返回给操作系统，用于提示程序是否正常完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="built_in">exit</span> ⑴；<span class="comment">//等价于return ⑴；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="打开流：fopen:">打开流：fopen:</h2><blockquote>
<p>原型：FILE <em> fopen(const char </em> path,const char * mode);<br>返回值：成功，返回文件指针，失败返回NULL，错误码保存在errno中 .<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FILE</span> *fp;</span><br><span class="line">fp = fopen(“/home/tianger/<span class="keyword">test</span>”,”r”);</span><br><span class="line"><span class="keyword">if</span>(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">     perror(“/home/tianger/<span class="keyword">test</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="关闭流：fclose：">关闭流：fclose：</h2><blockquote>
<p>原型：int fclose( FILE *fp );<br>返回值：成功，返回0；失败，返回EOF(-1)</p>
</blockquote>
<p>关闭fopen打开的fp</p>
<blockquote>
<p>fclose(fp);<br>fp = NULL;</p>
</blockquote>
<h2 id="读缓冲区：fread:">读缓冲区：fread:</h2><p>fread从一个文件流中读数据，最多读取count个元素，每个元素size字节，如果调用成功返回实际读取到的元素个数，如果不成功或读到文件末尾返回 0</p>
<blockquote>
<p>原型：size_t fread ( void <em>buffer, size_t size, size_t count, FILE </em>stream) ;<br>参数:<br>buffer  用于接收数据的内存地址<br>size  要读的每个数据项的字节数，单位是字节<br>count 要读count个数据项，每个数据项size个字节.<br>stream   输入流<br>返回值：实际读取的元素个数。如果返回值与count不相同，则可能文件结尾或发生错误。从ferror和feof获取错误信息或检测是否到达文件结尾。</p>
</blockquote>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE*stream;</span><br><span class="line">    <span class="keyword">char</span> msg[]=<span class="string">"this is a test"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span>((stream=fopen(<span class="string">"tianger.txt"</span>,<span class="string">"w+"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Can not open output file.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*write some data to the file*/</span></span><br><span class="line">    fwrite(msg,<span class="built_in">strlen</span>(msg)+<span class="number">1</span>,<span class="number">1</span>,stream);</span><br><span class="line">    <span class="comment">/*sizeof（char）=1 seek to the beginning of the file*/</span></span><br><span class="line">    fseek(stream,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="comment">/*read the data and display it*/</span></span><br><span class="line">    fread(buf,<span class="built_in">strlen</span>(msg)+<span class="number">1</span>,<span class="number">1</span>,stream);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br>产生一个tianger.txt文件，并打印 this is a test.</p>
<h2 id="写缓冲区:_fwrite:">写缓冲区: fwrite:</h2><p>fwrite 指向文件写入一个数据块.fwrite只是把程序先写到缓冲区，真正写入到文件，由操作系统决定，如果此时你想快速把缓冲区内容写入到文件，可以调用fflush()来实现。</p>
<blockquote>
<p>原型：size_t fwrite(const void<em> buffer, size_t size, size_t count, FILE</em> stream);<br>返回值：返回实际写入的数据块数目<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE * pFile;</span><br><span class="line">    <span class="keyword">char</span> buffer[] = &#123; <span class="string">'x'</span> , <span class="string">'y'</span> , <span class="string">'z'</span> &#125;;</span><br><span class="line">    pFile = fopen ( <span class="string">"tianger.txt"</span> , <span class="string">"wb"</span> );</span><br><span class="line">    fwrite (buffer , <span class="keyword">sizeof</span>(buffer), <span class="number">1</span> , pFile );</span><br><span class="line">    fclose (pFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>输出:<br>往文件tianger.txt中写入xyz</p>
<h2 id="移动文件流的读写位置:fseek()">移动文件流的读写位置:fseek()</h2><blockquote>
<p>原型：int fseek(FILE *stream, long offset, int fromwhere);<br>返回值：如果执行成功，stream将指向以fromwhere为基准，偏移offset（指针偏移量）个字节的位置，函数返回0。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置，函数返回一个非0值。</p>
</blockquote>
<p>示例参考fread中的用法。</p>
<h2 id="缓冲区强制物理写入：fflush()">缓冲区强制物理写入：fflush()</h2><p>fflush()用来清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入。</p>
<blockquote>
<p>原型：int fflush(FILE *stream);<br>返回值：成功，返回0；失败，返回EOF(-1)。</p>
</blockquote>
<p>在上面fwite写完后，fflpsu(fp); 即执行缓冲区内容写入文件。</p>
<h2 id="格式化字符：sprintf():">格式化字符：sprintf():</h2><p>sprintf()是字符串格式化命令，主要功能是把格式化的数据写入某个字符串中，它是一个可变参数函数。</p>
<blockquote>
<p>原型：int sprintf(char <em>buffer,char const </em>format, …)<br>参数：<br>buffer：char型指针，指向将要写入的字符串的缓冲区。<br>format：格式化字符串。<br>[argument]…：可选参数，可以是任何类型的数据。<br>返回值：<br>     返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1，并且 errno 会被设置为 EINVAL。<br>     sprintf 返回被写入buffer 的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。</p>
</blockquote>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>  buffer[<span class="number">200</span>], s[] = <span class="string">"computer"</span>, c = <span class="string">'l'</span>;</span><br><span class="line">  <span class="keyword">int</span>  i = <span class="number">35</span>, j;</span><br><span class="line">  <span class="keyword">float</span> fp = <span class="number">1.7320534f</span>;</span><br><span class="line">  <span class="comment">// 格式化并打印各种数据到buffer</span></span><br><span class="line">  j  = <span class="built_in">sprintf</span>( buffer,    <span class="string">"  String:    %s\n"</span>, s ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Character: %c\n"</span>, c ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Integer:  %d\n"</span>, i ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Real:      %f\n"</span>, fp );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"Output:\n%s\ncharacter count = %d\n"</span>,buffer,j );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br>Output:<br>  String:    computer<br>  Character: l<br>  Integer:  35<br>  Real:      1.732053</p>
<p>character count = 74</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/18/c-and-point-fourteen-define/" itemprop="url">
                C与指针-第十四章--预处理器
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-18T19:49:36+08:00" content="2016-06-18">
            2016-06-18
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/18/c-and-point-fourteen-define/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/18/c-and-point-fourteen-define/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>预处理器是在真正的编译开始之前由编译器调用的独立程序。预处理器可以删除注释、包含其他文件以及执行宏（宏macro是一段重复文字的简短描写）替代。预处理器可由语言（如C，PHP要求或以后作为提供额外功能（诸如为FORTRAN提供Ratfor预处理器）的附加软件。</p>
<h2 id="预定义宏">预定义宏</h2><p>ANSI C定义了一些宏。虽然每一个可以供您使用的编程，预定义宏不应该被直接修改。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DATE</strong></td>
<td style="text-align:center">“Jun 18 2016”</td>
<td style="text-align:center">文件被编译的时间</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td style="text-align:center">“15:47:03”</td>
<td style="text-align:center">文件被编译的时间</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td style="text-align:center">“test.c”</td>
<td style="text-align:center">进行编译的源文件名</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td style="text-align:center">“8”</td>
<td style="text-align:center">文件当前的行号</td>
</tr>
<tr>
<td><strong>STDC</strong></td>
<td style="text-align:center">“1”</td>
<td style="text-align:center">如果编译器遵循ANSI C，其值就为1，否则未定义</td>
</tr>
</tbody>
</table>
<p>例子：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"File :<span class="variable">%s</span>\n"</span>, __FILE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Date :<span class="variable">%s</span>\n"</span>, __DATE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Time :<span class="variable">%s</span>\n"</span>, __TIME_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Line :<span class="variable">%d</span>\n"</span>, __LINE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"ANSI :<span class="variable">%d</span>\n"</span>, __STDC_<span class="number">_</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>File :test.c<br>Date :Jun 18 2016<br>Time :15:47:03<br>Line :8<br>ANSI :1</p>
</blockquote>
<h2 id="预处理常量_define：">预处理常量 define：</h2><p>预处理器指令从#开始，到最后第一个换行符为止。如果在结尾出现反斜杠，则定义会自动延续到下一行。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*<span class="keyword">define</span>定义一个常量<span class="title">MAX_VALUE</span>*/</span><br><span class="line"><span class="comment">#define MAX_VALUE 10</span></span><br><span class="line">/*<span class="keyword">define</span>结尾出现反斜杠，定义自动延续到下一行*/</span><br><span class="line">#<span class="title">define</span> PARAGRAPH “This is the first example\</span><br><span class="line">of <span class="keyword">define</span> "</span><br><span class="line"></span><br><span class="line"><span class="title">printf</span>(“max value is %d\n”,MAX_VALUE);</span><br><span class="line">printf(“paragraph is %s\n”,PARAGRAPH);</span><br></pre></td></tr></table></figure></p>
<p>每个define行有三部分组成。</p>
<blockquote>
<ul>
<li>第一部分为#define本身；</li>
<li>第二部分为所选择的缩略语，成为宏，宏的名字中不允许有空格，我们约定使用大写表示。<br>*第三部分为宏替换的文本，成为宏展开。如果没有替换文本，我们成为一个基本宏定义。</li>
</ul>
</blockquote>
<h2 id="宏判断：">宏判断：</h2><p>如果我们想一些段落代码，只在部分宏有定义的情况下才只用，我们这里会用到宏判断。<br>格式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line">...</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PROJECT_TEST</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">ifdef</span> PROJECT_TEST</span></span><br><span class="line">        <span class="built_in">printf</span>(“marco PROJECT_TEST is defined\n”);</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(“marco PROJECT_TEST not defined\n”);</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们在工程中定义了PROJECT_TEST这个宏，则打印第一段，否则打印第二段。</p>
<h2 id="宏函数：">宏函数：</h2><blockquote>
<p>宏函数，即用宏的方式来实现函数。<br>宏函数末尾不能带分号做结尾。<br>宏函数中的参数都需要用括号扩起来。</p>
</blockquote>
<p>例如:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define SEQUERE(a) a*a</span></span><br><span class="line"><span class="keyword">int</span> seq_value;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">seq_value = SEQUERE(a);</span><br><span class="line"><span class="keyword">printf</span>(“seq_value = <span class="variable">%d</span>\n”,seq_value);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：16</p>
<p>但是这种写法有个问题，如果我们传入的a为 a+1时，就会发生问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> seq_value;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">seq_value = SEQUERE(a+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(“seq_value = %d\n”,seq_value);</span><br></pre></td></tr></table></figure></p>
<p>输出: 9<br>输出的内容为9，而不是我们期望的25.<br>我们简化一下这个程序</p>
<p>SEQUERE(a) a<em>a<br>变为a+1</em>a+1<br>a为4，所以结果为4+1*4+1 = 9.</p>
</blockquote>
<p>为了避免这种情况，我们在宏函数中的每个参数都需要用小括号()括起来。<br>即为#define SEQUERE(a) （a）*（a）</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/15/c-and-point-thirteen-function-point/" itemprop="url">
                C与指针-第十三章-函数指针
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-15T22:08:39+08:00" content="2016-06-15">
            2016-06-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/15/c-and-point-thirteen-function-point/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/15/c-and-point-thirteen-function-point/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本文重点讲的函数指针为 回调函数和转移表。</p>
<h2 id="回调函数">回调函数</h2><h3 id="含义：">含义：</h3><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<h3 id="机制：">机制：</h3><blockquote>
<p>⑴定义一个回调函数；<br>⑵提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；<br>⑶当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</p>
</blockquote>
<h3 id="举例：">举例：</h3><p> 1.我们在路上遇到一个好多年没见到的朋友，要了朋友的手机好，跟他说我回去打给你</p>
<blockquote>
<p> 1)遇见朋友–主函数<br>  2)我打电话给朋友，通过朋友的手机号，找到朋友–(回调)</p>
</blockquote>
<p>2.寄快递的情形<br>   打电话给快递员，告诉他我的地址(理解成回调函数的地址)，快递员在有空的时候根据这个地址来找到你取件。</p>
<blockquote>
<p>1)打电话给快递员，告诉他我的地址–主函数(我的地址–回调函数地址)<br>  2)快递员处理完其他事情后，通过这个地址(回调)来找到你取件，执行完回调里面的内容。</p>
</blockquote>
<p>示例:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*回调函数*/</span></span><br><span class="line"><span class="keyword">void</span> *call_phone_number(<span class="keyword">int</span> number )</span><br><span class="line">&#123;</span><br><span class="line">      printf(<span class="string">"phone number = %d\n"</span>,number); <span class="comment">/*通过号码找到朋友*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_call</span>(<span class="params"> <span class="keyword">void</span> *call_back(<span class="keyword">int</span> number</span>))</span><br><span class="line"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> phone_number = <span class="number">12345</span>;</span><br><span class="line">      call_back(phone_number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">      start_call(call_phone_number);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="转移表">转移表</h2><p>用函数指针的形式来替换switch、if/else的方式</p>
<h3 id="示例：">示例：</h3><p>一个计算器实现<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">double add(double,double);</span><br><span class="line">double sub(double,double);</span><br><span class="line">double mul(double,double);</span><br><span class="line">double <span class="keyword">div</span>(double,double);</span><br><span class="line"></span><br><span class="line">     switch(oper)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">ADD</span>:</span><br><span class="line">               <span class="literal">result</span> = add(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">SUB</span>:</span><br><span class="line">               <span class="literal">result</span> = sub(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">MUL</span>:</span><br><span class="line">               <span class="literal">result</span> = mul(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">DIV</span>:</span><br><span class="line">               <span class="literal">result</span> = <span class="keyword">div</span>(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          default:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码改成转移表只需要两个步骤。<br>首先，声明并初始化一个函数指针数组。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double (*oper_func[])(double,double)=&#123;add,sub,mil,div&#125;;</span><br><span class="line"></span><br><span class="line">调用：</span><br><span class="line">result = oper_func[<span class="link_label">oper</span>](<span class="link_url">op1,op2</span>);</span><br></pre></td></tr></table></figure></p>
<p>oper从数组中选择正确的函数指针，而函数调用操作符将执行这个函数</p>
<p>=========================<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/14/c-and-point-twelve-linknode/" itemprop="url">
                C与指针-第十二章 链表
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-14T22:25:42+08:00" content="2016-06-14">
            2016-06-14
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/14/c-and-point-twelve-linknode/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/c-and-point-twelve-linknode/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<h3 id="链表细则：">链表细则：</h3><p>1)是由结构体和指针构成的。<br>2)包括两个部分一个是数据域和指针域。<br>3)链表中的结点分为两类：头结点和一般结点。头结点是没有数据域的。<br>4)基本操作有：初始化链表，增加结点和删除结点，求链表的长度等等。</p>
<p>链表主要包括：单向链表，双向链表，循环链表。</p>
<h2 id="单向链表">单向链表</h2><h3 id="含义：">含义：</h3><p>单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始；链表是使用指针进行构造的列表；又称为结点列表，因为链表是由一个个结点组装起来的；其中每个结点都有指针成员变量指向列表中的下一个结点；<br>列表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向nuLL的指针。</p>
<h3 id="用法：">用法：</h3><p>//一个链表结构体的声明<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *next;</span><br><span class="line">	int	  data;</span><br><span class="line">&#125;Node;</span></span><br></pre></td></tr></table></figure></p>
<p>单链表的指向，链表的起始位置我们成为根指针(root)，它指向链表的第一个节点。根指针不包含任何数据，它只是一个指针。<br>Node *root;<br>下一个节点的访问通过root-&gt;next来实现<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/single-link.png" alt=""></p>
<h3 id="1-初始化链表：">1.初始化链表：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitNodeList</span><span class="params">(Node **node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//链表分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span>(!*node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	(*node)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：初始化时，这里的指针为二级指针，因为我们想要获取链表的根指针，如果只传入一级指针，malloc后得到的为分配内存的首地址给node，而不能被主函数中指针变量root得到这个地址。</p>
</blockquote>
<h3 id="2-插入数据：">2.插入数据：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">按值的大小顺序进行插入，把值插入到合适的位置</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> InsertNodeList(Node **root,<span class="keyword">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">  Node *current;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  Node *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">  current = *root;</span><br><span class="line">  <span class="keyword">previous</span> = <span class="keyword">NULL</span>; <span class="comment">/*用于判断新插入的值是否在第一个节点*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*寻找正确的插入位置，按序访问链表，直到到达一个其值大于或等于新值的节点*/</span></span><br><span class="line">  <span class="keyword">while</span>(current != <span class="keyword">NULL</span> &amp;&amp; current-&gt;data &lt; data)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">previous</span> = current;</span><br><span class="line">    current  = current-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*新节点分配内存空间*/</span></span><br><span class="line">  <span class="keyword">new</span> = (Node *)malloc(sizeof(Node));</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*新节点插入链表*/</span></span><br><span class="line">  <span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">  <span class="comment">/*如果插入的值在根节点，把新节点指向根节点，否则前一个节点，指向新节点*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">previous</span> == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *root = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">previous</span>-&gt;<span class="keyword">next</span> = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-获取链表长度">3.获取链表长度</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LengthNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  <span class="keyword">previous</span>=root-&gt;<span class="keyword">next</span>;<span class="comment">/*p指向链表的第一个结点。*/</span></span><br><span class="line">  <span class="comment">/*循环链表，直到节点为空*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">previous</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">previous</span>=<span class="keyword">previous</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除节点：">4.删除节点：</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void DestroyNodeList(Node <span class="keyword">*</span>root)</span><br><span class="line">&#123;</span><br><span class="line">  Node <span class="keyword">*</span>current,<span class="keyword">*</span>next;</span><br><span class="line">  current=root;/<span class="keyword">*</span>current 指向链表的根结点<span class="keyword">*</span>/</span><br><span class="line">  /<span class="keyword">*</span>当节点指向为空，即到了链表末尾，跳出<span class="keyword">*</span>/</span><br><span class="line">  while(current)</span><br><span class="line">  &#123;</span><br><span class="line">    next = current-&gt;next;/<span class="keyword">*</span>指向当前结点的下一个结点。<span class="keyword">*</span>/</span><br><span class="line">    free(current);/<span class="keyword">*</span>释放当前结点<span class="keyword">*</span>/</span><br><span class="line">    current = next;/<span class="keyword">*</span>指向下一个结点<span class="keyword">*</span>/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调用：">5.调用：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node *root;</span><br><span class="line">	<span class="keyword">int</span> node_length = <span class="number">0</span>;</span><br><span class="line">	InitNodeList(&amp;root);  <span class="comment">/*初始化链表，得到一个跟节点*/</span></span><br><span class="line">	InsertNodeList(&amp;root,<span class="number">10</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	node_length = LengthNodeList(root); <span class="comment">/*获取链表长度*/</span></span><br><span class="line">	DestroyNodeList(root); <span class="comment">/*销毁链表*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表">双向链表</h2><h3 id="含义：-1">含义：</h3><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<h3 id="特点：">特点：</h3><blockquote>
<pre><code><span class="number">1</span>）在数据结构中具有双向指针
<span class="number">2</span>）插入、删除数据的时候需要考虑前后的方向的操作
</code></pre></blockquote>
<h3 id="用法：-1">用法：</h3><p>一个链表结构体的声明<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">	int	  data;</span><br><span class="line">&#125;<span class="constant">Node</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xn24x.com1.z0.glb.clouddn.com/mutl-link.png" alt=""></p>
<h3 id="1-初始化链表：-1">1.初始化链表：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitNodeList</span><span class="params">(Node **node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//链表分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span>(!*node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	(*node)-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">	(*node)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.插入数据：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> InsertNodeList(register Node *root,<span class="keyword">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">  register Node *<span class="keyword">this</span>;</span><br><span class="line">  register Node *<span class="keyword">next</span>;</span><br><span class="line">  register Node *newnode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">this</span> = root;(<span class="keyword">next</span> = <span class="keyword">this</span>-&gt;<span class="keyword">next</span>)!= <span class="keyword">NULL</span>; <span class="keyword">this</span> =<span class="keyword">next</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">next</span>-&gt;data == data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">next</span>-&gt;data &gt; data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">/*新节点分配内存空间*/</span></span><br><span class="line">  newnode = (Node *)malloc(sizeof(Node));</span><br><span class="line">  <span class="keyword">if</span>(newnode == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*新节点插入链表*/</span></span><br><span class="line">  newnode-&gt;data = data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*插入新节点*/</span></span><br><span class="line">  newnode-&gt;<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="keyword">next</span> = newnode;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != root)</span><br><span class="line">  &#123;</span><br><span class="line">    newnode-&gt;prev = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    newnode-&gt;prev = <span class="keyword">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">next</span> != <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">next</span>-&gt;prev = newnode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    root-&gt;prev = newnode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-获取链表长度-1">3.获取链表长度</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LengthNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  <span class="keyword">previous</span>=root-&gt;<span class="keyword">next</span>;<span class="comment">/*p指向链表的第一个结点。*/</span></span><br><span class="line">  <span class="comment">/*循环链表，直到节点为空*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">previous</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">previous</span>=<span class="keyword">previous</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除节点：-1">4.删除节点：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DestroyNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  Node *current,*<span class="keyword">next</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  current=root;<span class="comment">/*current 指向链表的根结点*/</span></span><br><span class="line">  <span class="comment">/*当节点指向为空，即到了链表末尾，跳出*/</span></span><br><span class="line">  <span class="keyword">while</span>(current)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">next</span> = current-&gt;<span class="keyword">next</span>;<span class="comment">/*指向当前结点的下一个结点。*/</span></span><br><span class="line">    free(current);<span class="comment">/*释放当前结点*/</span></span><br><span class="line">    current = <span class="keyword">next</span>;<span class="comment">/*指向下一个结点*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调用：-1">5.调用：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node *root;</span><br><span class="line">	<span class="keyword">int</span> node_length = <span class="number">0</span>;</span><br><span class="line">	InitNodeList(&amp;root);  <span class="comment">/*初始化链表，得到一个跟节点*/</span></span><br><span class="line">	InsertNodeList(root,<span class="number">10</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	InsertNodeList(root,<span class="number">20</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	node_length = LengthNodeList(root); <span class="comment">/*获取链表长度*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,node_length);</span><br><span class="line">	DestroyNodeList(root); <span class="comment">/*销毁链表*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt="">    </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xn24x.com1.z0.glb.clouddn.com/headphoto.png" alt="Tianger Ge" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Tianger Ge</p>
        </div>
        <p class="site-description motion-element" itemprop="description">3G/LTE protocol | C</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">47</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tianger Ge</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tianger"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
