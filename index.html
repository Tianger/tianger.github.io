<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="3G/LTE protocol | C" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="3G/LTE protocol | C">
<meta property="og:type" content="website">
<meta property="og:title" content="Tianger's Family">
<meta property="og:url" content="http://tianger.github.io/index.html">
<meta property="og:site_name" content="Tianger's Family">
<meta property="og:description" content="3G/LTE protocol | C">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tianger's Family">
<meta name="twitter:description" content="3G/LTE protocol | C">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Tianger's Family </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3000033e6d5b1f1f2b431451efbce4ef";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Tianger's Family</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/21/c-and-point-seventeen-stack/" itemprop="url">
                C与指针-第十七章[1]-堆栈
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-21T20:56:42+08:00" content="2016-06-21">
            2016-06-21
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/21/c-and-point-seventeen-stack/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/21/c-and-point-seventeen-stack/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>抽象数据类型(ADT)是C程序员不可或缺的工具，这类ADT有链表、堆栈、队列和树等，前面我们已经讨论过了链表，接下来我们来学习堆栈、队列和树。</p>
<p>所有的ADT都需要确定一件事情–如何获取内存来存储值，这里有三种方案：</p>
<blockquote>
<p>1)静态数组<br>2）动态内存分配<br>3）动态链表存储</p>
</blockquote>
<p>本章主要讲解堆栈的操作方式，并用上述三种方式分别来实现堆栈的操作。</p>
<blockquote>
<p>栈的特点：后进先出(Last in First out –LIFO)<br>例如向仓库里堆放货品，后放进去的靠近门口，因此也会先拿出去</p>
</blockquote>
<h3 id="栈操作：">栈操作：</h3><p>入栈(push):<br>将数据保存到栈顶的操作。进入栈操作前，先修改栈顶指针，使其向上移动一个元素位置，然后将数据保存到栈顶指针所指的位置。</p>
<p>出栈(pop)：<br>将栈顶数据弹出操作，通过修改栈顶指针，使其指向栈中的下一个元素。</p>
<h3 id="堆栈实现：">堆栈实现：</h3><h4 id="1)静态数组操作：">1)静态数组操作：</h4><p>  这一节堆栈的操作以int类型进行入栈、出栈</p>
<blockquote>
<p>stack.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> STACK_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈顶指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否为空： TRUE-栈为空; FALSE--栈不为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否已满，TRUE--栈满; FALSE--栈不满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>stack.c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_SIZE    <span class="number">100</span>  <span class="comment">/*栈中元素数量的限制*/</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> top_element = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  top_element += <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">stack</span>[top_element] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is_empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = <span class="built_in">stack</span>[top_element];</span><br><span class="line">  top_element -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈顶指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">stack</span>[top_element];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否为空： TRUE-栈为空; FALSE--栈不为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (top_element == -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否已满，TRUE--栈满; FALSE--栈不满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> top_element == STACK_SIZE -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  push(<span class="number">10</span>);</span><br><span class="line">  push(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">int</span> temp = pop();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"temp = %d\n"</span>,temp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2）动态内存分配">2）动态内存分配</h4><blockquote>
<p>stack.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> STACK_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_stack</span><span class="params">(size_t size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory_stack</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈顶指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否为空： TRUE-栈为空; FALSE--栈不为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否已满，TRUE--栈满; FALSE--栈不满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>stack.c<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include "stack.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>    *stack;</span><br><span class="line"><span class="keyword">static</span> size_t stack_size;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>    top_element = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_stack</span>(<span class="params">size_t size</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">   stack_size = size;</span><br><span class="line">   stack = malloc(stack_size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">   <span class="keyword">if</span> (stack == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      printf(<span class="string">"create_stack fail\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory_stack</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (stack_size &gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    stack_size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  free(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  top_element += <span class="number">1</span>;</span><br><span class="line">  stack[top_element] = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is_empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = stack[top_element];</span><br><span class="line">  top_element -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈顶指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> stack[top_element];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否为空： TRUE-栈为空; FALSE--栈不为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (top_element == -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈是否已满，TRUE--栈满; FALSE--栈不满*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> top_element == stack_size -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  create_stack(<span class="number">100</span>); <span class="comment">/*创建堆栈*/</span></span><br><span class="line">  push(<span class="number">10</span>); <span class="comment">/*入栈*/</span></span><br><span class="line">  push(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">int</span> temp = pop(); <span class="comment">/*出栈*/</span></span><br><span class="line">  printf(<span class="string">"temp = %d\n"</span>,temp);</span><br><span class="line">  destory_stack(); <span class="comment">/*销毁栈*/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="3）数据链表操作：">3）数据链表操作：</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">#define</span> MAX_LEN <span class="number">100</span></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    char *top; <span class="comment">//栈顶</span></span><br><span class="line">    char *base;<span class="comment">//栈底</span></span><br><span class="line">    int stacksize;<span class="comment">//栈大小</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈的初始化*/</span></span><br><span class="line"><span class="literal">void</span> init_stack(<span class="built_in">stack</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    s<span class="subst">-&gt;</span>base = (char *)malloc(MAX_LEN * sizeof(char));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> == s)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s<span class="subst">-&gt;</span>top = s<span class="subst">-&gt;</span>base;</span><br><span class="line">    s<span class="subst">-&gt;</span>stacksize = MAX_LEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈的销毁*/</span></span><br><span class="line"><span class="literal">void</span> destory(<span class="built_in">stack</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> == s<span class="subst">-&gt;</span>base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    free(s<span class="subst">-&gt;</span>base);</span><br><span class="line">    s<span class="subst">-&gt;</span>top = s<span class="subst">-&gt;</span>base = <span class="built_in">NULL</span>;</span><br><span class="line">    s<span class="subst">-&gt;</span>stacksize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清空栈*/</span></span><br><span class="line"><span class="literal">void</span> clear(<span class="built_in">stack</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> == s<span class="subst">-&gt;</span>base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s<span class="subst">-&gt;</span>top = s<span class="subst">-&gt;</span>base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="literal">void</span> push(<span class="built_in">stack</span> *s,char elem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//s是否已满，若栈满，重新分配空间</span></span><br><span class="line">  <span class="keyword">if</span> ((s<span class="subst">-&gt;</span>top<span class="attribute">-s</span><span class="subst">-&gt;</span>base)&gt;STACK_INIT_SIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    s<span class="subst">-&gt;</span>base = (char*)realloc(s<span class="subst">-&gt;</span>base,(STACKINCRENMENT+STACK_INIT_SIZE)*sizeof(char));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> == s<span class="subst">-&gt;</span>base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将栈顶指针指向栈顶</span></span><br><span class="line">    s<span class="subst">-&gt;</span>top = s<span class="subst">-&gt;</span>base+s<span class="subst">-&gt;</span>stacksize;</span><br><span class="line">    s<span class="subst">-&gt;</span>stacksize += MAX_LEN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将元素e，写入栈顶，注意这里可能有错。</span></span><br><span class="line">   *(s<span class="subst">-&gt;</span>top)=elem;</span><br><span class="line">   s<span class="subst">-&gt;</span>top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line">char pop(<span class="built_in">stack</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//保存栈顶元素</span></span><br><span class="line">    char topelement;</span><br><span class="line">    <span class="comment">//如果栈顶指针指向与栈底指针指向同一内存单元时，表示栈为空或者栈不存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s<span class="subst">-&gt;</span>top == s<span class="subst">-&gt;</span>base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//栈顶元素= 栈的top - 1；</span></span><br><span class="line">   topelement = *(s<span class="subst">-&gt;</span>top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> topelement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MAX_LEN 100</span></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span>  *top;</span><br><span class="line">  <span class="keyword">char</span>  *tail;</span><br><span class="line">  <span class="keyword">int</span>    stacksize;</span><br><span class="line">&#125;stack;</span><br><span class="line"></span><br><span class="line">void init_stack(stack *s)</span><br><span class="line">&#123;</span><br><span class="line">  s-&gt;tail = (<span class="keyword">char</span> *)malloc(MAX_LEN*sizeof(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">NULL</span> == s)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;top = s-&gt;tail;</span><br><span class="line">  s-&gt;stacksize = MAX_LEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void destory_stack(stack *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">NULL</span> == s-&gt;tail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  free(s-&gt;tail);</span><br><span class="line">  s-&gt;top = s-&gt;tail = <span class="keyword">NULL</span>;</span><br><span class="line">  s-&gt;stacksize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear_stack(stack *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">NULL</span> == s-&gt;tail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;top = s-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(stack *s,<span class="keyword">char</span> elem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//if stack is full,need malloc new space</span></span><br><span class="line">  <span class="keyword">if</span> ((s-&gt;top - s-&gt;tail) &gt; MAX_LEN)</span><br><span class="line">  &#123;</span><br><span class="line">    s-&gt;tail = (<span class="keyword">char</span> *)malloc(MAX_LEN *sizeof(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">NULL</span> == s-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top = s-&gt;tail + s-&gt;stacksize;</span><br><span class="line">    s-&gt;stacksize += MAX_LEN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *(s-&gt;top) = elem;</span><br><span class="line">  s-&gt;top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pop(stack *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> topelem;</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;top == s-&gt;tail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  topelem = *(s-&gt;top - <span class="number">1</span>);</span><br><span class="line">  s-&gt;top--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> topelem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">  stack s;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> *elem = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//INI STACK</span></span><br><span class="line">  init_stack(&amp;s);</span><br><span class="line">  printf(<span class="string">"进栈顺序\r\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环打印elem的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*elem != <span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    push(&amp;s,*elem);</span><br><span class="line">    printf(<span class="string">"%3c\r\n"</span>,*elem);</span><br><span class="line">    elem++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出栈</span></span><br><span class="line">  printf(<span class="string">"出栈顺序\r\n"</span>);</span><br><span class="line">  <span class="keyword">while</span>((s.top != <span class="keyword">NULL</span>) &amp;&amp; (s.tail != <span class="keyword">NULL</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    printf(<span class="string">"%3c\r\n"</span>,pop(&amp;s));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear_stack(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/19/c-and-point-sixteen-stander/" itemprop="url">
                C与指针-第十六章-标准函数库
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-19T20:51:29+08:00" content="2016-06-19">
            2016-06-19
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/19/c-and-point-sixteen-stander/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/19/c-and-point-sixteen-stander/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本章主要来讲一些之前没用用过的标准函数库。分为整数函数、浮点型函数、日期和时间函数等。</p>
<h2 id="整数函数：">整数函数：</h2><p>整数函数的返回值为整型值，分为三类：算术、随机数和字符串转换。</p>
<h3 id="算术：">算术：</h3><p>标准函数库包含了4个整型算术函数—abs\labs\ div\ldiv</p>
<h4 id="abs—求绝对值:">abs—求绝对值:</h4><blockquote>
<p>原型：int abs(int value);<br>函数说明：abs用来计算传入参数的绝对值，然后将结果返回。<br>用法：<br>int answer;<br>answer = abs(-12);//answer 返回为-12的绝对值，结果为12</p>
</blockquote>
<h4 id="labs—求绝对值：">labs—求绝对值：</h4><blockquote>
<p>原型：long int labs(long int value);<br>返回值：labs跟abs一样，用来计算绝对值，但是labs支持长度为long int类型，长度更长。<br>用法：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long <span class="literal">result</span>;</span><br><span class="line">long x = -<span class="number">12345678</span>L; //长度范围超过了<span class="type">int</span>的最大范围</span><br><span class="line"><span class="literal">result</span>= labs(x);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="div—两个整数相除：">div—两个整数相除：</h4><blockquote>
<p>原型：div_t div(int numerator,int denominator);<br>返回值：返回商和余数<br>用法：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div_t q;</span><br><span class="line">q = div(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">printf("<span class="number">8</span> div <span class="number">3</span> = %d, remainder = %d\n", q.quot,q.<span class="comment">rem);</span></span><br></pre></td></tr></table></figure></p>
<p>输出：<br>8 div 3 = 3, remainder = 1</p>
</blockquote>
<h4 id="ldiv—两个整数相除：">ldiv—两个整数相除：</h4><blockquote>
<p>原型：ldiv_t ldiv(long int numer, long int denom);<br>返回值：返回商和余数<br>用法：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldiv_t lx;</span><br><span class="line">lx = ldiv(<span class="number">100000</span>L, <span class="number">30000</span>L);</span><br><span class="line">printf("<span class="number">100000</span> div <span class="number">30000</span> = %ld remainder %ld\n", lx.quot, lx.<span class="comment">rem);</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>100000 div 30000 = 3 remainder 10000</p>
</blockquote>
<h3 id="随机数：">随机数：</h3><p>在我们常用的一些加密、模拟操作的时候，需要用到随机数，这里有两个函数(rand\srand)合在一起使用能够产生伪随机数。</p>
<blockquote>
<p>伪随机数：通过计算产生随机数，有可能重复，因此不是真正的随机数。</p>
</blockquote>
<h4 id="rand—产生随机数：">rand—产生随机数：</h4><blockquote>
<p>原型：int rand():<br>用法：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>  <span class="built_in">number</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">number</span> = rand()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="srand_—提供随机数种子：">srand —提供随机数种子：</h4><blockquote>
<p>原型：void srand(unsigned int seed);<br>这里的seed是rand函数的种子，用来初始化rand()的初始值。</p>
</blockquote>
<p>rand调用之前，需要用srand产生一个种子，如果没有用主动调用srand，系统也会默认使用srand(1)。</p>
<p>通常情况下，srand后面跟时间函数来完成随机种子生成，减少随机数相同的可能性。</p>
<blockquote>
<p>srand((unsigned)time(NULL));<br>int a = rand();</p>
</blockquote>
<h3 id="字符串转换：">字符串转换：</h3><p>字符串转换函数把字符串转换成数值，常用的有atoi\atol.</p>
<h4 id="atoi—字符串转成整数：">atoi—字符串转成整数：</h4><blockquote>
<p>原型：int atoi(const char *nptr);<br>返回值：参数nptr字符串，如果第一个非空格字符存在，是数字或者正负号则开始做类型转换，之后检测到非数字(包括结束符 \0) 字符时停止转换，返回整型数。否则，返回零。</p>
</blockquote>
<p>示例：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = <span class="string">"12345.67"</span>;</span><br><span class="line">n = atoi(<span class="keyword">str</span>);  <span class="comment">//n的值为12345</span></span><br></pre></td></tr></table></figure></p>
<h4 id="atol—字符串转成长整形:">atol—字符串转成长整形:</h4><blockquote>
<p>原型：long atol(const char *nptr);<br>返回值:<br>返回转换后的长整型数。如果传入的字符串为空，或者字符串包含的内容非阿拉伯数字序列，则函数返回默认值0。</p>
</blockquote>
<p>示例：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> l;</span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = <span class="string">"98765432"</span>;</span><br><span class="line">l = atol(<span class="keyword">str</span>); <span class="comment">//l为98765432</span></span><br></pre></td></tr></table></figure></p>
<h2 id="浮点型函数：">浮点型函数：</h2><p>头文件math.h包含了函数库中剩余的数学函数的声明。这些函数的返回值以及绝大多数都是double类型。<br>常用的数学函数有三角函数、双曲线函数、对数和指数函数</p>
<h3 id="三角函数：">三角函数：</h3><blockquote>
<p>double sin(double angle);<br>double cos(double angle);<br>double tan(double angle);<br>double asin(double value);<br>double acos(double value);<br>double atan(double value);</p>
</blockquote>
<p>sin\cos和tan函数的参数是一个用弧度表示的角度，这些函数分包返回这个角度的正弦、余弦和正切值。<br>asin、acos和atan函数分别返回它们的参数的反正弦、反余弦和反正切。</p>
<h3 id="双曲线函数：">双曲线函数：</h3><blockquote>
<p>double sinh(double angle);<br>double cosh(double angle);<br>double tanh(double angle);</p>
</blockquote>
<p>这些函数分别返回它们的参数的双曲正弦、双曲余弦和双曲正切。每个函数的参数都是一个以弧度表示的角度。</p>
<h3 id="对数和指数函数：">对数和指数函数：</h3><blockquote>
<p>double exp(double x);<br>double log(double x);<br>double log10(double x);</p>
</blockquote>
<p>exp函数返回e值的x次幂<br>log函数返回x以e为第的对数，也就是常说的自然对数。log10函数返回x以10为底的对数。</p>
<h2 id="日期和时间函数：">日期和时间函数：</h2><p>日期处理函数需要引用头文件&lt; time.h&gt;</p>
<h3 id="当天时间:">当天时间:</h3><h4 id="time:">time:</h4><blockquote>
<p>原型:time_t time(time_t *returned_value);<br>返回值：如果参数是一个非NULL的指针，时间值也将通过这个指针进行存储。如果机器无法提供当前的日期和时间，或者时间值太大，无法用time_t变量表示，函数就返回-1.</p>
</blockquote>
<h4 id="ctime:">ctime:</h4><blockquote>
<p>原型:char <em>ctime(const time_t </em>timep);<br>说明：ctime将参数timep所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串返回。</p>
</blockquote>
<p>示例：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time_t timer<span class="comment">;</span></span><br><span class="line">time<span class="list">(<span class="keyword">&amp;timer</span>)</span><span class="comment">;</span></span><br><span class="line">printf<span class="list">(<span class="string">"%s\n"</span>,ctime<span class="list">(<span class="keyword">&amp;timer</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>Sun Jun 19 12:47:41 2016</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/19/c-and-point-io/" itemprop="url">
                C与指针-第十五章--输入/输出
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-19T16:20:24+08:00" content="2016-06-19">
            2016-06-19
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/19/c-and-point-io/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/19/c-and-point-io/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本章主要讨论ANSI C的输入和输出(I/O)函数。首先需要看两个错误和退出的函数。</p>
<h2 id="错误报错perror:">错误报错perror:</h2><blockquote>
<p>原型：void perror(char const *message);<br>头文件： &lt; stdio.h&gt; , &lt; stdlib.h&gt;</p>
</blockquote>
<p>如果message不是NULL，并且指向一个非空的字符串，perror函数就打印出这个字符串。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">FILE</span> *fp;</span><br><span class="line">fp = fopen(“/home/tianger/<span class="keyword">test</span>”,”r”);</span><br><span class="line"><span class="keyword">if</span>(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">     perror(“/home/tianger/<span class="keyword">test</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>/home/tianger/test：No such file or directory</p>
</blockquote>
<h2 id="终止执行exit：">终止执行exit：</h2><blockquote>
<p>原型：void exit(int status)；<br>头文件: &lt; stdlib.h&gt;</p>
</blockquote>
<p>exit,用于终止一个程序的执行，传入的status参数返回给操作系统，用于提示程序是否正常完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="built_in">exit</span> ⑴；<span class="comment">//等价于return ⑴；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="打开流：fopen:">打开流：fopen:</h2><blockquote>
<p>原型：FILE <em> fopen(const char </em> path,const char * mode);<br>返回值：成功，返回文件指针，失败返回NULL，错误码保存在errno中 .<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FILE</span> *fp;</span><br><span class="line">fp = fopen(“/home/tianger/<span class="keyword">test</span>”,”r”);</span><br><span class="line"><span class="keyword">if</span>(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">     perror(“/home/tianger/<span class="keyword">test</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="关闭流：fclose：">关闭流：fclose：</h2><blockquote>
<p>原型：int fclose( FILE *fp );<br>返回值：成功，返回0；失败，返回EOF(-1)</p>
</blockquote>
<p>关闭fopen打开的fp</p>
<blockquote>
<p>fclose(fp);<br>fp = NULL;</p>
</blockquote>
<h2 id="读缓冲区：fread:">读缓冲区：fread:</h2><p>fread从一个文件流中读数据，最多读取count个元素，每个元素size字节，如果调用成功返回实际读取到的元素个数，如果不成功或读到文件末尾返回 0</p>
<blockquote>
<p>原型：size_t fread ( void <em>buffer, size_t size, size_t count, FILE </em>stream) ;<br>参数:<br>buffer  用于接收数据的内存地址<br>size  要读的每个数据项的字节数，单位是字节<br>count 要读count个数据项，每个数据项size个字节.<br>stream   输入流<br>返回值：实际读取的元素个数。如果返回值与count不相同，则可能文件结尾或发生错误。从ferror和feof获取错误信息或检测是否到达文件结尾。</p>
</blockquote>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE*stream;</span><br><span class="line">    <span class="keyword">char</span> msg[]=<span class="string">"this is a test"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span>((stream=fopen(<span class="string">"tianger.txt"</span>,<span class="string">"w+"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Can not open output file.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*write some data to the file*/</span></span><br><span class="line">    fwrite(msg,<span class="built_in">strlen</span>(msg)+<span class="number">1</span>,<span class="number">1</span>,stream);</span><br><span class="line">    <span class="comment">/*sizeof（char）=1 seek to the beginning of the file*/</span></span><br><span class="line">    fseek(stream,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="comment">/*read the data and display it*/</span></span><br><span class="line">    fread(buf,<span class="built_in">strlen</span>(msg)+<span class="number">1</span>,<span class="number">1</span>,stream);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br>产生一个tianger.txt文件，并打印 this is a test.</p>
<h2 id="写缓冲区:_fwrite:">写缓冲区: fwrite:</h2><p>fwrite 指向文件写入一个数据块.fwrite只是把程序先写到缓冲区，真正写入到文件，由操作系统决定，如果此时你想快速把缓冲区内容写入到文件，可以调用fflush()来实现。</p>
<blockquote>
<p>原型：size_t fwrite(const void<em> buffer, size_t size, size_t count, FILE</em> stream);<br>返回值：返回实际写入的数据块数目<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE * pFile;</span><br><span class="line">    <span class="keyword">char</span> buffer[] = &#123; <span class="string">'x'</span> , <span class="string">'y'</span> , <span class="string">'z'</span> &#125;;</span><br><span class="line">    pFile = fopen ( <span class="string">"tianger.txt"</span> , <span class="string">"wb"</span> );</span><br><span class="line">    fwrite (buffer , <span class="keyword">sizeof</span>(buffer), <span class="number">1</span> , pFile );</span><br><span class="line">    fclose (pFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>输出:<br>往文件tianger.txt中写入xyz</p>
<h2 id="移动文件流的读写位置:fseek()">移动文件流的读写位置:fseek()</h2><blockquote>
<p>原型：int fseek(FILE *stream, long offset, int fromwhere);<br>返回值：如果执行成功，stream将指向以fromwhere为基准，偏移offset（指针偏移量）个字节的位置，函数返回0。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置，函数返回一个非0值。</p>
</blockquote>
<p>示例参考fread中的用法。</p>
<h2 id="缓冲区强制物理写入：fflush()">缓冲区强制物理写入：fflush()</h2><p>fflush()用来清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入。</p>
<blockquote>
<p>原型：int fflush(FILE *stream);<br>返回值：成功，返回0；失败，返回EOF(-1)。</p>
</blockquote>
<p>在上面fwite写完后，fflpsu(fp); 即执行缓冲区内容写入文件。</p>
<h2 id="格式化字符：sprintf():">格式化字符：sprintf():</h2><p>sprintf()是字符串格式化命令，主要功能是把格式化的数据写入某个字符串中，它是一个可变参数函数。</p>
<blockquote>
<p>原型：int sprintf(char <em>buffer,char const </em>format, …)<br>参数：<br>buffer：char型指针，指向将要写入的字符串的缓冲区。<br>format：格式化字符串。<br>[argument]…：可选参数，可以是任何类型的数据。<br>返回值：<br>     返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1，并且 errno 会被设置为 EINVAL。<br>     sprintf 返回被写入buffer 的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。</p>
</blockquote>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>  buffer[<span class="number">200</span>], s[] = <span class="string">"computer"</span>, c = <span class="string">'l'</span>;</span><br><span class="line">  <span class="keyword">int</span>  i = <span class="number">35</span>, j;</span><br><span class="line">  <span class="keyword">float</span> fp = <span class="number">1.7320534f</span>;</span><br><span class="line">  <span class="comment">// 格式化并打印各种数据到buffer</span></span><br><span class="line">  j  = <span class="built_in">sprintf</span>( buffer,    <span class="string">"  String:    %s\n"</span>, s ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Character: %c\n"</span>, c ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Integer:  %d\n"</span>, i ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Real:      %f\n"</span>, fp );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"Output:\n%s\ncharacter count = %d\n"</span>,buffer,j );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br>Output:<br>  String:    computer<br>  Character: l<br>  Integer:  35<br>  Real:      1.732053</p>
<p>character count = 74</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/18/c-and-point-fourteen-define/" itemprop="url">
                C与指针-第十四章--预处理器
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-18T19:49:36+08:00" content="2016-06-18">
            2016-06-18
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/18/c-and-point-fourteen-define/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/18/c-and-point-fourteen-define/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>预处理器是在真正的编译开始之前由编译器调用的独立程序。预处理器可以删除注释、包含其他文件以及执行宏（宏macro是一段重复文字的简短描写）替代。预处理器可由语言（如C，PHP要求或以后作为提供额外功能（诸如为FORTRAN提供Ratfor预处理器）的附加软件。</p>
<h2 id="预定义宏">预定义宏</h2><p>ANSI C定义了一些宏。虽然每一个可以供您使用的编程，预定义宏不应该被直接修改。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DATE</strong></td>
<td style="text-align:center">“Jun 18 2016”</td>
<td style="text-align:center">文件被编译的时间</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td style="text-align:center">“15:47:03”</td>
<td style="text-align:center">文件被编译的时间</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td style="text-align:center">“test.c”</td>
<td style="text-align:center">进行编译的源文件名</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td style="text-align:center">“8”</td>
<td style="text-align:center">文件当前的行号</td>
</tr>
<tr>
<td><strong>STDC</strong></td>
<td style="text-align:center">“1”</td>
<td style="text-align:center">如果编译器遵循ANSI C，其值就为1，否则未定义</td>
</tr>
</tbody>
</table>
<p>例子：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"File :<span class="variable">%s</span>\n"</span>, __FILE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Date :<span class="variable">%s</span>\n"</span>, __DATE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Time :<span class="variable">%s</span>\n"</span>, __TIME_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Line :<span class="variable">%d</span>\n"</span>, __LINE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"ANSI :<span class="variable">%d</span>\n"</span>, __STDC_<span class="number">_</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>File :test.c<br>Date :Jun 18 2016<br>Time :15:47:03<br>Line :8<br>ANSI :1</p>
</blockquote>
<h2 id="预处理常量_define：">预处理常量 define：</h2><p>预处理器指令从#开始，到最后第一个换行符为止。如果在结尾出现反斜杠，则定义会自动延续到下一行。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*<span class="keyword">define</span>定义一个常量<span class="title">MAX_VALUE</span>*/</span><br><span class="line"><span class="comment">#define MAX_VALUE 10</span></span><br><span class="line">/*<span class="keyword">define</span>结尾出现反斜杠，定义自动延续到下一行*/</span><br><span class="line">#<span class="title">define</span> PARAGRAPH “This is the first example\</span><br><span class="line">of <span class="keyword">define</span> "</span><br><span class="line"></span><br><span class="line"><span class="title">printf</span>(“max value is %d\n”,MAX_VALUE);</span><br><span class="line">printf(“paragraph is %s\n”,PARAGRAPH);</span><br></pre></td></tr></table></figure></p>
<p>每个define行有三部分组成。</p>
<blockquote>
<ul>
<li>第一部分为#define本身；</li>
<li>第二部分为所选择的缩略语，成为宏，宏的名字中不允许有空格，我们约定使用大写表示。<br>*第三部分为宏替换的文本，成为宏展开。如果没有替换文本，我们成为一个基本宏定义。</li>
</ul>
</blockquote>
<h2 id="宏判断：">宏判断：</h2><p>如果我们想一些段落代码，只在部分宏有定义的情况下才只用，我们这里会用到宏判断。<br>格式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line">...</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PROJECT_TEST</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">ifdef</span> PROJECT_TEST</span></span><br><span class="line">        <span class="built_in">printf</span>(“marco PROJECT_TEST is defined\n”);</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(“marco PROJECT_TEST not defined\n”);</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们在工程中定义了PROJECT_TEST这个宏，则打印第一段，否则打印第二段。</p>
<h2 id="宏函数：">宏函数：</h2><blockquote>
<p>宏函数，即用宏的方式来实现函数。<br>宏函数末尾不能带分号做结尾。<br>宏函数中的参数都需要用括号扩起来。</p>
</blockquote>
<p>例如:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define SEQUERE(a) a*a</span></span><br><span class="line"><span class="keyword">int</span> seq_value;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">seq_value = SEQUERE(a);</span><br><span class="line"><span class="keyword">printf</span>(“seq_value = <span class="variable">%d</span>\n”,seq_value);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：16</p>
<p>但是这种写法有个问题，如果我们传入的a为 a+1时，就会发生问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> seq_value;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">seq_value = SEQUERE(a+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(“seq_value = %d\n”,seq_value);</span><br></pre></td></tr></table></figure></p>
<p>输出: 9<br>输出的内容为9，而不是我们期望的25.<br>我们简化一下这个程序</p>
<p>SEQUERE(a) a<em>a<br>变为a+1</em>a+1<br>a为4，所以结果为4+1*4+1 = 9.</p>
</blockquote>
<p>为了避免这种情况，我们在宏函数中的每个参数都需要用小括号()括起来。<br>即为#define SEQUERE(a) （a）*（a）</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/15/c-and-point-thirteen-function-point/" itemprop="url">
                C与指针-第十三章-函数指针
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-15T22:08:39+08:00" content="2016-06-15">
            2016-06-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/15/c-and-point-thirteen-function-point/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/15/c-and-point-thirteen-function-point/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本文重点讲的函数指针为 回调函数和转移表。</p>
<h2 id="回调函数">回调函数</h2><h3 id="含义：">含义：</h3><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<h3 id="机制：">机制：</h3><blockquote>
<p>⑴定义一个回调函数；<br>⑵提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；<br>⑶当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</p>
</blockquote>
<h3 id="举例：">举例：</h3><p> 1.我们在路上遇到一个好多年没见到的朋友，要了朋友的手机好，跟他说我回去打给你</p>
<blockquote>
<p> 1)遇见朋友–主函数<br>  2)我打电话给朋友，通过朋友的手机号，找到朋友–(回调)</p>
</blockquote>
<p>2.寄快递的情形<br>   打电话给快递员，告诉他我的地址(理解成回调函数的地址)，快递员在有空的时候根据这个地址来找到你取件。</p>
<blockquote>
<p>1)打电话给快递员，告诉他我的地址–主函数(我的地址–回调函数地址)<br>  2)快递员处理完其他事情后，通过这个地址(回调)来找到你取件，执行完回调里面的内容。</p>
</blockquote>
<p>示例:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*回调函数*/</span></span><br><span class="line"><span class="keyword">void</span> *call_phone_number(<span class="keyword">int</span> number )</span><br><span class="line">&#123;</span><br><span class="line">      printf(<span class="string">"phone number = %d\n"</span>,number); <span class="comment">/*通过号码找到朋友*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_call</span>(<span class="params"> <span class="keyword">void</span> *call_back(<span class="keyword">int</span> number</span>))</span><br><span class="line"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> phone_number = <span class="number">12345</span>;</span><br><span class="line">      call_back(phone_number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">      start_call(call_phone_number);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="转移表">转移表</h2><p>用函数指针的形式来替换switch、if/else的方式</p>
<h3 id="示例：">示例：</h3><p>一个计算器实现<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">double add(double,double);</span><br><span class="line">double sub(double,double);</span><br><span class="line">double mul(double,double);</span><br><span class="line">double <span class="keyword">div</span>(double,double);</span><br><span class="line"></span><br><span class="line">     switch(oper)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">ADD</span>:</span><br><span class="line">               <span class="literal">result</span> = add(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">SUB</span>:</span><br><span class="line">               <span class="literal">result</span> = sub(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">MUL</span>:</span><br><span class="line">               <span class="literal">result</span> = mul(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">DIV</span>:</span><br><span class="line">               <span class="literal">result</span> = <span class="keyword">div</span>(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          default:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码改成转移表只需要两个步骤。<br>首先，声明并初始化一个函数指针数组。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double (*oper_func[])(double,double)=&#123;add,sub,mil,div&#125;;</span><br><span class="line"></span><br><span class="line">调用：</span><br><span class="line">result = oper_func[<span class="link_label">oper</span>](<span class="link_url">op1,op2</span>);</span><br></pre></td></tr></table></figure></p>
<p>oper从数组中选择正确的函数指针，而函数调用操作符将执行这个函数</p>
<p>=========================<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/14/c-and-point-twelve-linknode/" itemprop="url">
                C与指针-第十二章 链表
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-14T22:25:42+08:00" content="2016-06-14">
            2016-06-14
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/14/c-and-point-twelve-linknode/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/c-and-point-twelve-linknode/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<h3 id="链表细则：">链表细则：</h3><p>1)是由结构体和指针构成的。<br>2)包括两个部分一个是数据域和指针域。<br>3)链表中的结点分为两类：头结点和一般结点。头结点是没有数据域的。<br>4)基本操作有：初始化链表，增加结点和删除结点，求链表的长度等等。</p>
<p>链表主要包括：单向链表，双向链表，循环链表。</p>
<h2 id="单向链表">单向链表</h2><h3 id="含义：">含义：</h3><p>单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始；链表是使用指针进行构造的列表；又称为结点列表，因为链表是由一个个结点组装起来的；其中每个结点都有指针成员变量指向列表中的下一个结点；<br>列表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向nuLL的指针。</p>
<h3 id="用法：">用法：</h3><p>//一个链表结构体的声明<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *next;</span><br><span class="line">	int	  data;</span><br><span class="line">&#125;Node;</span></span><br></pre></td></tr></table></figure></p>
<p>单链表的指向，链表的起始位置我们成为根指针(root)，它指向链表的第一个节点。根指针不包含任何数据，它只是一个指针。<br>Node *root;<br>下一个节点的访问通过root-&gt;next来实现<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/single-link.png" alt=""></p>
<h3 id="1-初始化链表：">1.初始化链表：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitNodeList</span><span class="params">(Node **node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//链表分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span>(!*node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	(*node)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：初始化时，这里的指针为二级指针，因为我们想要获取链表的根指针，如果只传入一级指针，malloc后得到的为分配内存的首地址给node，而不能被主函数中指针变量root得到这个地址。</p>
</blockquote>
<h3 id="2-插入数据：">2.插入数据：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">按值的大小顺序进行插入，把值插入到合适的位置</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> InsertNodeList(Node **root,<span class="keyword">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">  Node *current;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  Node *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">  current = *root;</span><br><span class="line">  <span class="keyword">previous</span> = <span class="keyword">NULL</span>; <span class="comment">/*用于判断新插入的值是否在第一个节点*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*寻找正确的插入位置，按序访问链表，直到到达一个其值大于或等于新值的节点*/</span></span><br><span class="line">  <span class="keyword">while</span>(current != <span class="keyword">NULL</span> &amp;&amp; current-&gt;data &lt; data)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">previous</span> = current;</span><br><span class="line">    current  = current-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*新节点分配内存空间*/</span></span><br><span class="line">  <span class="keyword">new</span> = (Node *)malloc(sizeof(Node));</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*新节点插入链表*/</span></span><br><span class="line">  <span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">  <span class="comment">/*如果插入的值在根节点，把新节点指向根节点，否则前一个节点，指向新节点*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">previous</span> == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *root = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">previous</span>-&gt;<span class="keyword">next</span> = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-获取链表长度">3.获取链表长度</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LengthNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  <span class="keyword">previous</span>=root-&gt;<span class="keyword">next</span>;<span class="comment">/*p指向链表的第一个结点。*/</span></span><br><span class="line">  <span class="comment">/*循环链表，直到节点为空*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">previous</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">previous</span>=<span class="keyword">previous</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除节点：">4.删除节点：</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void DestroyNodeList(Node <span class="keyword">*</span>root)</span><br><span class="line">&#123;</span><br><span class="line">  Node <span class="keyword">*</span>current,<span class="keyword">*</span>next;</span><br><span class="line">  current=root;/<span class="keyword">*</span>current 指向链表的根结点<span class="keyword">*</span>/</span><br><span class="line">  /<span class="keyword">*</span>当节点指向为空，即到了链表末尾，跳出<span class="keyword">*</span>/</span><br><span class="line">  while(current)</span><br><span class="line">  &#123;</span><br><span class="line">    next = current-&gt;next;/<span class="keyword">*</span>指向当前结点的下一个结点。<span class="keyword">*</span>/</span><br><span class="line">    free(current);/<span class="keyword">*</span>释放当前结点<span class="keyword">*</span>/</span><br><span class="line">    current = next;/<span class="keyword">*</span>指向下一个结点<span class="keyword">*</span>/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调用：">5.调用：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node *root;</span><br><span class="line">	<span class="keyword">int</span> node_length = <span class="number">0</span>;</span><br><span class="line">	InitNodeList(&amp;root);  <span class="comment">/*初始化链表，得到一个跟节点*/</span></span><br><span class="line">	InsertNodeList(&amp;root,<span class="number">10</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	node_length = LengthNodeList(root); <span class="comment">/*获取链表长度*/</span></span><br><span class="line">	DestroyNodeList(root); <span class="comment">/*销毁链表*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表">双向链表</h2><h3 id="含义：-1">含义：</h3><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<h3 id="特点：">特点：</h3><blockquote>
<pre><code><span class="number">1</span>）在数据结构中具有双向指针
<span class="number">2</span>）插入、删除数据的时候需要考虑前后的方向的操作
</code></pre></blockquote>
<h3 id="用法：-1">用法：</h3><p>一个链表结构体的声明<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">	int	  data;</span><br><span class="line">&#125;<span class="constant">Node</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xn24x.com1.z0.glb.clouddn.com/mutl-link.png" alt=""></p>
<h3 id="1-初始化链表：-1">1.初始化链表：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitNodeList</span><span class="params">(Node **node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//链表分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span>(!*node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	(*node)-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">	(*node)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.插入数据：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> InsertNodeList(register Node *root,<span class="keyword">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">  register Node *<span class="keyword">this</span>;</span><br><span class="line">  register Node *<span class="keyword">next</span>;</span><br><span class="line">  register Node *newnode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">this</span> = root;(<span class="keyword">next</span> = <span class="keyword">this</span>-&gt;<span class="keyword">next</span>)!= <span class="keyword">NULL</span>; <span class="keyword">this</span> =<span class="keyword">next</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">next</span>-&gt;data == data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">next</span>-&gt;data &gt; data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">/*新节点分配内存空间*/</span></span><br><span class="line">  newnode = (Node *)malloc(sizeof(Node));</span><br><span class="line">  <span class="keyword">if</span>(newnode == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*新节点插入链表*/</span></span><br><span class="line">  newnode-&gt;data = data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*插入新节点*/</span></span><br><span class="line">  newnode-&gt;<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="keyword">next</span> = newnode;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != root)</span><br><span class="line">  &#123;</span><br><span class="line">    newnode-&gt;prev = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    newnode-&gt;prev = <span class="keyword">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">next</span> != <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">next</span>-&gt;prev = newnode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    root-&gt;prev = newnode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-获取链表长度-1">3.获取链表长度</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LengthNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  <span class="keyword">previous</span>=root-&gt;<span class="keyword">next</span>;<span class="comment">/*p指向链表的第一个结点。*/</span></span><br><span class="line">  <span class="comment">/*循环链表，直到节点为空*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">previous</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">previous</span>=<span class="keyword">previous</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除节点：-1">4.删除节点：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DestroyNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  Node *current,*<span class="keyword">next</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  current=root;<span class="comment">/*current 指向链表的根结点*/</span></span><br><span class="line">  <span class="comment">/*当节点指向为空，即到了链表末尾，跳出*/</span></span><br><span class="line">  <span class="keyword">while</span>(current)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">next</span> = current-&gt;<span class="keyword">next</span>;<span class="comment">/*指向当前结点的下一个结点。*/</span></span><br><span class="line">    free(current);<span class="comment">/*释放当前结点*/</span></span><br><span class="line">    current = <span class="keyword">next</span>;<span class="comment">/*指向下一个结点*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调用：-1">5.调用：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node *root;</span><br><span class="line">	<span class="keyword">int</span> node_length = <span class="number">0</span>;</span><br><span class="line">	InitNodeList(&amp;root);  <span class="comment">/*初始化链表，得到一个跟节点*/</span></span><br><span class="line">	InsertNodeList(root,<span class="number">10</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	InsertNodeList(root,<span class="number">20</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	node_length = LengthNodeList(root); <span class="comment">/*获取链表长度*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,node_length);</span><br><span class="line">	DestroyNodeList(root); <span class="comment">/*销毁链表*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt="">    </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/11/c-and-point-eleven-malloc-and-free/" itemprop="url">
                C与指针-第十一章—动态内存分配
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-11T22:22:28+08:00" content="2016-06-11">
            2016-06-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/11/c-and-point-eleven-malloc-and-free/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/11/c-and-point-eleven-malloc-and-free/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>我们使用数组时，它是存储于内存中连续的位置上，它所需要的内存在编译时就被分配，使用起来比较方便，但是也存在几个缺点。</p>
<h3 id="数组的缺点:">数组的缺点:</h3><p>1)假如一个数组无限大，而我们只需要很少的几个字节，这就会造成内存浪费，增加了内存的开销。<br>2)我们我们访问超过数组下标的内容时，造成数组越界，有可能产生一个异常值，从而导致失败。</p>
<p>针对这两点，动态内存分配的处理就相对比较适用。动态内存分配中使用的几个关键字<br>malloc和free，这两个是成对出现的，malloc用来申请内存空间，free用来释放内存。</p>
<h2 id="malloc和free">malloc和free</h2><p>malloc从内存池中提取一块合适的内存，并向该程序返回一个指向这块内存的指针。这块内存没有初始化。<br>当内存不再使用时，调用free把这块内存归还给内存池。</p>
<h3 id="原型：">原型：</h3><blockquote>
<p>void <em>malloc(size_t size);<br>void free(void </em>pointer);</p>
</blockquote>
<p>malloc的参数是需要分配的内存字节数。<br>malloc分配的是一块连续的内存。如果请求分配的是100个字节，那么实际分配的就是100个连续的字节，不会分开于两块或多块不同的内存。<br>如果内存池为空，或者申请内存不成功，malloc就会返回一个NULL指针。如果需要对分配的内存进行检查，可以通过与NULL指针进行比较来判断内存是否分配成功。</p>
<p>free的参数必须是从malloc、calloc或relloc返回的值，或者是NULL。传递NULL指针不会产生任何效果。</p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">...</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">100</span>);     <span class="comment">//申请内存空间</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0x0</span>,<span class="number">100</span>);  <span class="comment">//清空内存</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>)  <span class="comment">//判断内存是否申请成功</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(“out of memory!\n”);</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a); <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure></p>
<h2 id="calloc和relloc">calloc和relloc</h2><h3 id="原型：-1">原型：</h3><blockquote>
<p>void <em>calloc(size_t num_elements, size_t element_size);<br>void realloc(void </em>ptr,size_t new_size);</p>
</blockquote>
<p>calloc用于内存的申请。<br>calloc与malloc之间的主要区别是calloc在返回指向内存的指针之前把它初始化为0。但是如果你的程序知识想把一些值存储到数组中，那么这个初始化过程纯属浪费时间。</p>
<p>relloc函数用于修改一个原先已经分配的内存块大小。使用这个函数，你可以使一块内存扩大或缩小。如果它用于扩大一个内存块，那么这块内存原先的内容依然保留，新增加的内存添加到原先内存块的后面，新的内存并未以任何方式进行初始化。该内存块尾部的部分内存便被拿掉，剩余部分内存的原先内容依然被保留。</p>
<p>如果realloc函数的第1个参数是NULL，那么它的行为就和malloc一样。</p>
<h2 id="内存泄漏：">内存泄漏：</h2><p>当动态分配的内存不再需要使用时，它应该被释放。如果内存不释放，将会引起内存泄漏。内存泄漏可以一点点的榨干可用内存，从而导致程序崩溃。</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/10/c-and-point-ten-struct/" itemprop="url">
                C与指针-第十章-结构体\联合union
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-10T22:49:51+08:00" content="2016-06-10">
            2016-06-10
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/10/c-and-point-ten-struct/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/10/c-and-point-ten-struct/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。</p>
<h2 id="含义：">含义：</h2><p>结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。</p>
<h2 id="定义与声明：">定义与声明：</h2><p>结构体的定义如下所示，struct为结构体关键字，tag为结构体的标志，member-list为结构体成员列表，其必须列出其所有成员；variable-list为此结构体声明的变量。</p>
<blockquote>
<p>struct tag {<br>member-list<br>} variable-list ;</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;s2;</span><br><span class="line">注：s1和s2被编译器当做两种截然不同的类型，即使他们成员列表相同。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">用标签来创建变量：</span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span> x;</span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span> y[<span class="number">20</span>];</span><br><span class="line">这里x和y是两个完全相同的类型，因为他们用标签来进行定义</span><br></pre></td></tr></table></figure>
<h2 id="typedef：">typedef：</h2><p>声明结构体时可以使用的另一种良好技巧是用typedef创建一种新的类型。</p>
<blockquote>
<p>typedef struct{<br>     int a;<br>     char b;<br>     double c;<br>}s3;</p>
</blockquote>
<p>这个技巧和标签的效果几乎完全相同，区别在于s3现在是个类型名而不是个结构标签。以后的声明如下：</p>
<blockquote>
<p>s3 x;<br>s3 y[20];</p>
</blockquote>
<h2 id="结构成员：">结构成员：</h2><p>结构体的成员可以是标量、数组、指针甚至是其他结构体。</p>
<blockquote>
<p>typedef struct{<br>     int a;<br>     char b;<br>     double c:<br>     s3 d;<br>     s3 e[10];<br>}s4;</p>
</blockquote>
<h3 id="1)直接访问">1)直接访问</h3><p>结构体成员通过’.’操作符来访问的。<br>例：<br>s4 comp;</p>
<p>访问成员a， comp.a;<br>访问成员d中的a， comp.d.a;<br>访问成员e中第5个元素的成员a，comp.e[4].a;</p>
<h3 id="2)间接访问">2)间接访问</h3><p>如果拥有一个指向结构体的指针，那么我们访问结构体成员需要用’-&gt;’操作符来访问。<br>s4 *comp;</p>
<p>访问成员a， comp-&gt;a;<br>访问成员d中的a， comp-&gt;d.a;<br>访问成员e中第5个元素的成员a，comp-&gt;e[4].a;</p>
<h2 id="联合：">联合：</h2><h3 id="含义：-1">含义：</h3><p>“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>
<blockquote>
<p>联合使用关键字union来定义。</p>
</blockquote>
<h3 id="声明：">声明：</h3><p>联合声明跟结构体类似。<br>union {<br>     数据成员；<br>}变量；</p>
<blockquote>
<p>union{<br>      int a;<br>     float b;<br>}message；</p>
</blockquote>
<p>在一个32位的机器上，变量message只占用内存中最大的变量类型的大小，这里int跟float占用内存相同，因此变量message这里只占用内存中一个32位的字。<br>如果a被访问，这个字就作为int型访问；<br>如果b被访问，这个字就作为float型访问。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>.b = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">message</span>.a = <span class="number">10</span>;</span><br><span class="line">printf(“%d\n”,<span class="keyword">message</span>.a);</span><br><span class="line">printf(“%f\n”,<span class="keyword">message</span>.b);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>由于最后一个访问的是a，因此a打印的值为10，b的值为0.000000；反之相同</p>
</blockquote>
<h3 id="union和结构体：">union和结构体：</h3><p>通常我们把union和struct结合起来使用，这样更加方便我们的程序开发。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     int age;</span><br><span class="line">     int height;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     int year;</span><br><span class="line">     char class_name[<span class="number">10</span>];</span><br><span class="line">     <span class="class"><span class="keyword">enum</span> &#123;<span class="title">class1</span>,<span class="title">class2</span>&#125; <span class="title">type</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span>  <span class="title">first_student</span>;</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span>  <span class="title">second_student</span>;</span></span><br><span class="line">     &#125;data;</span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    int y;</span><br><span class="line">    int z;</span><br><span class="line">   <span class="regexp">/*msg相关变量赋值*/</span></span><br><span class="line">    msg.data.first_student.age = <span class="number">10</span>;</span><br><span class="line">    msg.data.first_student.height = <span class="number">170</span>;</span><br><span class="line">    msg.<span class="keyword">type</span> = class1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msg.<span class="keyword">type</span> == class1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">/*union一次只能访问一个成员*/</span></span><br><span class="line">         y = msg.data.first_student.age;</span><br><span class="line">         z = msg.data.first_student.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         y = msg.data.second_student.age;</span><br><span class="line">         z = msg.data.second_student.height;</span><br><span class="line">    &#125;</span><br><span class="line">      printf(<span class="string">"%d\n"</span>,y);  <span class="regexp">//</span>打印<span class="number">10</span></span><br><span class="line">      printf(<span class="string">"%d\n"</span>,z);  <span class="regexp">//</span>打印<span class="number">170</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结：">总结：</h2><p>1.结构体中，不同类型的值可以存储在一起，成员可以是标量、数组、指针或结构体<br>2.不同的二结构体声明即使它们的成员列表相同也被认为是不同的类型，typedef可以用于解决此问题<br>3.联合的所有成员都存储于同一个内存位置，通过访问不同类型的联合成员，内存中相同的位组合可以被解释为不同的东西。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/09/c-and-point-nine-char/" itemprop="url">
                C与指针-第九章-字符、字符串处理API
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-09T23:08:16+08:00" content="2016-06-09">
            2016-06-09
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/09/c-and-point-nine-char/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/09/c-and-point-nine-char/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>字符串是一种重要的数据类型，但是C语言并没有显式的字符串数据类型，因此字符串以字符串常量的形式出现或存储于字符数组中。字符串常量很适用于那些程序不会对它们进行修改的字符串。所有其他字符串都必须存储于字符数组或动态分配的内存中。本次主要描述处理字符串和字符的库函数。</p>
<p>字符串就是一串零个或多个字符，并且以一个位模式为全0的NUL字节结尾。因此，字符串所包含的字符内部不能出现NUL字节。<br>     字符、字符串处理需要引入string.h这个头文件</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span>
</code></pre><h2 id="1-字符串长度">1.字符串长度</h2><p>API: strlen<br>原型：size_t strlen(char const *string)<br>返回值:string字符串的长度，不包括结束符\0<br>作用：strlen返回一个类型为sizt_t的值，属于一个无符号整数类型。即为传入字符串的长度<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br></pre></td></tr></table></figure></p>
<p>这里i打印值为5，即为字符串hello的长度，不包含结束符。</p>
<p>尝试模仿strlen的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strlen(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*<span class="built_in">string</span>++ != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-复制字符串">2.复制字符串</h2><h3 id="1)不受长度限制">1)不受长度限制</h3><p>API：strcpy<br>原型：char <em>strcpy(char </em>dst,char const *src)<br>返回值：返回指向dst字符串的指针<br>作用：这个函数把参数src字符串复制到dst参数。如果参数src和dst在内存中出现重叠，其结果是未定义的。dst必须是一个字符数组或者是一个指向动态分配内存的数组的指针。<br>     src赋值给dst，dst以前的内容将会被覆盖丢失.如果src的长度超过了dst数组的长度，执行时会crash<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,<span class="string">"message"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line"> 输出内容为 message</span><br></pre></td></tr></table></figure></p>
<p>模仿strcpy的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制">2)长度受限制</h3><p>API:strncpy<br>原型：char <em>strncpy(char </em>dst, char const *src, size_t len);<br>返回值：返回指向dst字符串的指针<br>作用：把src字符串的字符复制到dst数组中。它总是正好向dst写入len个字符。如果strlen(src)的值小于len，dst数组会用额外的NUL字节填充到len长度。如果strlne(src)的值大于或等于len，那么只有len 个字符被复制到dst中。<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(buf,<span class="string">"A message"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">//输出A mes world，长度为5，其余的不拷贝</span></span><br><span class="line"><span class="built_in">strncpy</span>(buf,<span class="string">"A message"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">//输出A message</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strncpy的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strncpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src ,<span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len &amp;&amp; src[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-连接字符串">3.连接字符串</h2><h3 id="1)不受长度限制-1">1)不受长度限制</h3><p>API: strcat<br>原型：char <em>strcat(char </em>dst, const char *src);<br>返回：返回指向dst字符串的指针<br>作用：把src的字符串添加(连接)到dst字符串后面。这里要求dst原先已经包含了一个字符串(可以为空字符串)。它找到这个字符串的末尾。并把src字符串的一份拷贝添加到这个位置。如果src和dst的位置发生重叠，其结果是未定义的。<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = “hello”;</span><br><span class="line"><span class="built_in">strcat</span>(buf,”world”);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出helloworld</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strcat的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_stcat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制-1">2)长度受限制</h3><p>API: strncat<br>原型：char <em>strncat(char </em>dst, const char *src,size_t len);<br>返回值：指向dst的指针<br>作用：从src中复制长度为len个字符到dst中<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = “hello”;</span><br><span class="line"><span class="built_in">strncat</span>(buf,”world”,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出hellowo</span></span><br><span class="line"><span class="built_in">strncat</span>(buf,”world”,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出helloworld，超过部分遇到\0结束符，不再进行连接</span></span><br></pre></td></tr></table></figure></p>
<p>模拟strncat：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_stncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src,size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len &amp;&amp; (*dst++ = *src++) != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-字符串比较">4.字符串比较</h2><h3 id="1)不受长度限制-2">1)不受长度限制</h3><p>API: strcmp<br>原型：int strcmp(const char <em>s1, const char </em>s2)<br>返回值：0表示两个字符串相同，其余表示两个字符串不同<br>作用：对两个字符串s1\s2逐个字符进行比较，直到发现不匹配为止<br>用法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">ret</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">ret</span> = strcmp(buf,<span class="string">"hello”);</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">ret</span>);//输出<span class="number">0</span>，两个字符串相同</span><br><span class="line"><span class="keyword">ret</span> = strcmp(buf,”hello world<span class="string">");</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">ret</span>);//输出-<span class="number">32</span>，两个字符串不同</span><br></pre></td></tr></table></figure></p>
<p>模仿strcmp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strcmp(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">NULL</span>) || (s2 == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制-2">2)长度受限制</h3><p>API: strncmp<br>原型：int strcmp(const char <em>s1, const char </em>s2,size_t len)<br>返回值：0表示两个字符串相同，其余表示两个字符串不同<br>作用：对两个字符串s1\s2逐个字符进行比较，直到发现不匹配为止<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = <span class="built_in">strncmp</span>(buf,<span class="string">"hello"</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret); <span class="comment">//输出0，表示hello中前两个字符he跟hello中前两个相同</span></span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">strncmp</span>(buf,<span class="string">"hello world"</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret); <span class="comment">//输出-32，表示不相等，即hello world前8个字符，与hello不相等</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strncmp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strncmp(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * s2,<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">NULL</span>) || (s2 == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-字符串查找">5.字符串查找</h2><p>原型：char strstr(char <em>s1, char </em>s2)<br>返回值：NULL，或者指向查找到的起始位置的指针<br>作用：这个函数在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针。如果s2并没有完整地出现在s1的任何地方，函数将返回一个NULL指针，如果s2是一个空字符串，函数就返回是</p>
<p>用法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line">char *<span class="keyword">last</span> = NULL;</span><br><span class="line"><span class="keyword">last</span> = strstr(buf,<span class="string">"he”);</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="keyword">last</span>); //打印hello</span><br><span class="line"><span class="keyword">last</span> = strstr(buf,<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="keyword">last</span>); //打印null</span><br></pre></td></tr></table></figure></p>
<p>模拟strstr写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">my_strstr</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> * s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*s1 == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*s1 != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s2[i] == <span class="string">'\0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> s1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s2[i] != s1[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        s1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-内存操作：">6.内存操作：</h2><p>主要有memcpy、memmove、memcmp、memchr、memset几个函数</p>
<h3 id="原型：">原型：</h3><blockquote>
<p>void <em>memcpy(void </em>dst,void const <em>src,size_t length);<br>void </em>memmove(void <em>dst,void const </em>src,size_t length);<br>void <em>memcmp(void const </em>s1,void const <em>s2,size_t length);<br>void </em>memchr(void <em>s1,void const </em>s2,size_t length);<br>void <em>memset(void </em>dst,int ch,size_t length);</p>
</blockquote>
<h3 id="用法:">用法:</h3><h3 id="memcpy">memcpy</h3><p>从src的起始位置赋值length个字节到dst的内存起始位置，可以复制任何类型。如果src和dst出现重叠，其结果是未知的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dst[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> src[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(dst,src,<span class="built_in">strlen</span>(src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,dst );</span><br></pre></td></tr></table></figure></p>
<p>模拟memcpy：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_memcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> * src,size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) &amp;&amp; (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len-- &gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="memmove：">memmove：</h3><p>memmove用于从src拷贝count个字符到dest，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中。但复制后src内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。<br>用法：<br>char s[]=”Golden Global View”;<br>memmove(s,s+7,strlen(s)+1-7);<br>printf(“%s”,s);<br>程序输出结果：Global View<br>*注意：这里的拷贝长度strlen(s)+1-7表示把字符串结尾的’\0’也拷贝进来。</p>
<h3 id="memcmp">memcmp</h3><p>memcmp是比较内存区域buf1和buf2的前count个字节。该函数是按字节比较的。<br>返回值：<br>当s1<s2时，返回值<0 当s1="=s2时，返回值=0">s2时，返回值&gt;0</s2时，返回值<0></p>
<blockquote>
<p>如:char <em>s1=”abc”;<br>char </em>s2=”acd”;<br>int r=memcmp(s1,s2,3);<br>就是比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了。所以r=-1</p>
</blockquote>
<h3 id="memchr:">memchr:</h3><p>从buf所指内存区域的前count个字节查找字符ch。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s=<span class="string">"Hello, Programmers!"</span>;</span><br><span class="line"><span class="keyword">void</span> *p;<span class="comment">//因为memchr(,,);return void*p;</span></span><br><span class="line">p=<span class="built_in">memchr</span>(s,<span class="string">'P'</span>,<span class="built_in">strlen</span>(s));</span><br><span class="line"><span class="comment">//p=(char *)memchr(s,'P',sizeof(s)); //s是一个指向char的指针，而任何指针都是个一个4字节的数，在这里应//该是要说明搜索整个字符串的长度，所以应该用strlen(s)</span></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s"</span>,p);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Not Found!"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="memst">memst</h3><p>将s所指向的某一块内存中的前n个 字节的内容全部设置为ch指定的ASCII值<br>通常用来进行内存初始化作用<br>例如：<br>char dst[20];<br>memset(dst,0x0,sizeof(dst)); //把dst指向的大小为20的内存区域值都设置为0.</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/07/c-and-point-eight/" itemprop="url">
                C与指针-第八章-数组
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-07T22:22:28+08:00" content="2016-06-07">
            2016-06-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/07/c-and-point-eight/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/07/c-and-point-eight/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>所谓数组，就是相同数据类型的元素按一定顺序排列的集合，就是把有限个类型相同的变量用一个名字命名，然后用编号区分他们的变量的集合，这个名字称为数组名，编号称为下标。</p>
<p>特点：只能存放一种类型的数据，如全部是int型或者全部是char型，数组里的数据成为元素。</p>
<h2 id="一维数组：">一维数组：</h2><h3 id="格式：">格式：</h3><p>类型 数组名[元素个数-常量表达式]<br>（1）数组名的命名方法与变量名相同，遵循标识符命名规则;<br>（2）数组是用方括号括起来的常量表达式，不能用圆括号;<br>（3）常量表达式表示数组元素的个数，即数组的长度，数组的下标从0开始，下标的最大值为:<br>常量表达式-1;<br>（4）常量表达式中可以包括常量和符号常量，不能包括变量。<br>可以用赋值语句或输入语句使数组中的元素得到值，但要占用运行时间。可以使数组在运行之前初始化，即在编译阶段使之得到初值。</p>
<h3 id="初始化：">初始化：</h3><p>int buf[5] = {1,2,3,4,5};<br>这里把buf数组中的5个元素初始化为1,2,3,4,5</p>
<h3 id="下标：">下标：</h3><p>这里变量buf称为数组，因为它是一些值的集合，下标和数组名一起使用，用于标示该集合中的某个特定的值。例如buf[0]表示数组buf的第一个元素的值，这里值为1. buf[4]标示数组buf第5个值，这里值为5.<br>buf[0]  //对应的值为1<br>buf[4] //对应的值为5<br>数组的下标从0开始计数</p>
<h2 id="多维数组：">多维数组：</h2><p>某个数组的维数不止1个，我们称这个数组为多维数组</p>
<h3 id="格式：-1">格式：</h3><p>数组［下标］［下标］</p>
<p>在引用二维数组时，必须是单个元素，不能是整个数组名。下标可以是一个表达式，但不能是变量。如果下标是一个表达式，注意表达式的值不能超出数组定义的上、下限。</p>
<p>int num[3][5];<br>创建了一个包含15个元素的矩阵。我们一般把这个理解为3行5列，当然也可以理解为5行3列，为了我们方便记忆，我们看做为3行10列。</p>
<p>(1) 多维数组初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num[<span class="number">3</span>][<span class="number">5</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;,&#123;<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span>，<span class="number">10</span>&#125;,&#123;<span class="number">11</span>，<span class="number">12</span>，<span class="number">13</span>，<span class="number">14</span>，<span class="number">15</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上赋值把第一个花括号内的数据赋给第一行元素，第二个花括号内数据赋给第二元素，以此类推，即按行赋值</p>
<p>(2) 可以将所有的数据写在一个花括号内，按数组排列的顺序对各元素赋值。</p>
<p>(3)可以对数组的部分元素赋初值。如:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int a[<span class="link_label">3</span>][<span class="link_reference">5</span>]  = &#123;&#123;1&#125;,&#123;6&#125;，&#123;11&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上赋值的结果是:数组第一列的元素分别赋了初值1，6，11，其余元素的值都是0。<br>(4)如果对二维数组的全部元素都赋初值，则定义数组时对第一维的长度可以不指定，但第二维的长度不能省。</p>
<h2 id="指针数组_&amp;数组指针：">指针数组 &amp;数组指针：</h2><p>　　指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。<br>　　数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。</p>
<p>例：</p>
<h3 id="指针数组：">指针数组：</h3><blockquote>
<p>int <em>num1[10];<br>“[]”的优先级比“</em>”要高,num1先与“[]”结合，构成一个数组的定义，数组名为num1.int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。</p>
</blockquote>
<h3 id="数组指针：">数组指针：</h3><blockquote>
<p>int (<em>num2)[10];<br>在这里“()”的优先级比“[]”高，“</em>”号和num2 构成一个指针的定义，指针变量名为num2,int 修饰的是数组的内容，即数组的每个元素。</p>
</blockquote>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xn24x.com1.z0.glb.clouddn.com/headphoto.png" alt="Tianger Ge" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Tianger Ge</p>
        </div>
        <p class="site-description motion-element" itemprop="description">3G/LTE protocol | C</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tianger Ge</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tianger"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
