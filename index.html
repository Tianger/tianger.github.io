<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="3G/LTE protocol | C" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="3G/LTE protocol | C">
<meta property="og:type" content="website">
<meta property="og:title" content="Tianger's Family">
<meta property="og:url" content="http://tianger.github.io/index.html">
<meta property="og:site_name" content="Tianger's Family">
<meta property="og:description" content="3G/LTE protocol | C">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tianger's Family">
<meta name="twitter:description" content="3G/LTE protocol | C">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Tianger's Family </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3000033e6d5b1f1f2b431451efbce4ef";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Tianger's Family</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/19/c-and-point-io/" itemprop="url">
                C与指针-第十五章--输入/输出
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-19T16:20:24+08:00" content="2016-06-19">
            2016-06-19
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/19/c-and-point-io/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/19/c-and-point-io/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本章主要讨论ANSI C的输入和输出(I/O)函数。首先需要看两个错误和退出的函数。</p>
<h2 id="错误报错perror:">错误报错perror:</h2><blockquote>
<p>原型：void perror(char const *message);<br>头文件： &lt; stdio.h&gt; , &lt; stdlib.h&gt;</p>
</blockquote>
<p>如果message不是NULL，并且指向一个非空的字符串，perror函数就打印出这个字符串。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">FILE</span> *fp;</span><br><span class="line">fp = fopen(“/home/tianger/<span class="keyword">test</span>”,”r”);</span><br><span class="line"><span class="keyword">if</span>(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">     perror(“/home/tianger/<span class="keyword">test</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>/home/tianger/test：No such file or directory</p>
</blockquote>
<h2 id="终止执行exit：">终止执行exit：</h2><blockquote>
<p>原型：void exit(int status)；<br>头文件: &lt; stdlib.h&gt;</p>
</blockquote>
<p>exit,用于终止一个程序的执行，传入的status参数返回给操作系统，用于提示程序是否正常完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="built_in">exit</span> ⑴；<span class="comment">//等价于return ⑴；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="打开流：fopen:">打开流：fopen:</h2><blockquote>
<p>原型：FILE <em> fopen(const char </em> path,const char * mode);<br>返回值：成功，返回文件指针，失败返回NULL，错误码保存在errno中 .<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FILE</span> *fp;</span><br><span class="line">fp = fopen(“/home/tianger/<span class="keyword">test</span>”,”r”);</span><br><span class="line"><span class="keyword">if</span>(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">     perror(“/home/tianger/<span class="keyword">test</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="关闭流：fclose：">关闭流：fclose：</h2><blockquote>
<p>原型：int fclose( FILE *fp );<br>返回值：成功，返回0；失败，返回EOF(-1)</p>
</blockquote>
<p>关闭fopen打开的fp</p>
<blockquote>
<p>fclose(fp);<br>fp = NULL;</p>
</blockquote>
<h2 id="读缓冲区：fread:">读缓冲区：fread:</h2><p>fread从一个文件流中读数据，最多读取count个元素，每个元素size字节，如果调用成功返回实际读取到的元素个数，如果不成功或读到文件末尾返回 0</p>
<blockquote>
<p>原型：size_t fread ( void <em>buffer, size_t size, size_t count, FILE </em>stream) ;<br>参数:<br>buffer  用于接收数据的内存地址<br>size  要读的每个数据项的字节数，单位是字节<br>count 要读count个数据项，每个数据项size个字节.<br>stream   输入流<br>返回值：实际读取的元素个数。如果返回值与count不相同，则可能文件结尾或发生错误。从ferror和feof获取错误信息或检测是否到达文件结尾。</p>
</blockquote>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE*stream;</span><br><span class="line">    <span class="keyword">char</span> msg[]=<span class="string">"this is a test"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span>((stream=fopen(<span class="string">"tianger.txt"</span>,<span class="string">"w+"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Can not open output file.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*write some data to the file*/</span></span><br><span class="line">    fwrite(msg,<span class="built_in">strlen</span>(msg)+<span class="number">1</span>,<span class="number">1</span>,stream);</span><br><span class="line">    <span class="comment">/*sizeof（char）=1 seek to the beginning of the file*/</span></span><br><span class="line">    fseek(stream,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="comment">/*read the data and display it*/</span></span><br><span class="line">    fread(buf,<span class="built_in">strlen</span>(msg)+<span class="number">1</span>,<span class="number">1</span>,stream);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br>产生一个tianger.txt文件，并打印 this is a test.</p>
<h2 id="写缓冲区:_fwrite:">写缓冲区: fwrite:</h2><p>fwrite 指向文件写入一个数据块.fwrite只是把程序先写到缓冲区，真正写入到文件，由操作系统决定，如果此时你想快速把缓冲区内容写入到文件，可以调用fflush()来实现。</p>
<blockquote>
<p>原型：size_t fwrite(const void<em> buffer, size_t size, size_t count, FILE</em> stream);<br>返回值：返回实际写入的数据块数目<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE * pFile;</span><br><span class="line">    <span class="keyword">char</span> buffer[] = &#123; <span class="string">'x'</span> , <span class="string">'y'</span> , <span class="string">'z'</span> &#125;;</span><br><span class="line">    pFile = fopen ( <span class="string">"tianger.txt"</span> , <span class="string">"wb"</span> );</span><br><span class="line">    fwrite (buffer , <span class="keyword">sizeof</span>(buffer), <span class="number">1</span> , pFile );</span><br><span class="line">    fclose (pFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>输出:<br>往文件tianger.txt中写入xyz</p>
<h2 id="移动文件流的读写位置:fseek()">移动文件流的读写位置:fseek()</h2><blockquote>
<p>原型：int fseek(FILE *stream, long offset, int fromwhere);<br>返回值：如果执行成功，stream将指向以fromwhere为基准，偏移offset（指针偏移量）个字节的位置，函数返回0。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置，函数返回一个非0值。</p>
</blockquote>
<p>示例参考fread中的用法。</p>
<h2 id="缓冲区强制物理写入：fflush()">缓冲区强制物理写入：fflush()</h2><p>fflush()用来清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入。</p>
<blockquote>
<p>原型：int fflush(FILE *stream);<br>返回值：成功，返回0；失败，返回EOF(-1)。</p>
</blockquote>
<p>在上面fwite写完后，fflpsu(fp); 即执行缓冲区内容写入文件。</p>
<h2 id="格式化字符：sprintf():">格式化字符：sprintf():</h2><p>sprintf()是字符串格式化命令，主要功能是把格式化的数据写入某个字符串中，它是一个可变参数函数。</p>
<blockquote>
<p>原型：int sprintf(char <em>buffer,char const </em>format, …)<br>参数：<br>buffer：char型指针，指向将要写入的字符串的缓冲区。<br>format：格式化字符串。<br>[argument]…：可选参数，可以是任何类型的数据。<br>返回值：<br>     返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1，并且 errno 会被设置为 EINVAL。<br>     sprintf 返回被写入buffer 的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。</p>
</blockquote>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>  buffer[<span class="number">200</span>], s[] = <span class="string">"computer"</span>, c = <span class="string">'l'</span>;</span><br><span class="line">  <span class="keyword">int</span>  i = <span class="number">35</span>, j;</span><br><span class="line">  <span class="keyword">float</span> fp = <span class="number">1.7320534f</span>;</span><br><span class="line">  <span class="comment">// 格式化并打印各种数据到buffer</span></span><br><span class="line">  j  = <span class="built_in">sprintf</span>( buffer,    <span class="string">"  String:    %s\n"</span>, s ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Character: %c\n"</span>, c ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Integer:  %d\n"</span>, i ); </span><br><span class="line">  j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"  Real:      %f\n"</span>, fp );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"Output:\n%s\ncharacter count = %d\n"</span>,buffer,j );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br>Output:<br>  String:    computer<br>  Character: l<br>  Integer:  35<br>  Real:      1.732053</p>
<p>character count = 74</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/18/c-and-point-fourteen-define/" itemprop="url">
                C与指针-第十四章--预处理器
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-18T19:49:36+08:00" content="2016-06-18">
            2016-06-18
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/18/c-and-point-fourteen-define/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/18/c-and-point-fourteen-define/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>预处理器是在真正的编译开始之前由编译器调用的独立程序。预处理器可以删除注释、包含其他文件以及执行宏（宏macro是一段重复文字的简短描写）替代。预处理器可由语言（如C，PHP要求或以后作为提供额外功能（诸如为FORTRAN提供Ratfor预处理器）的附加软件。</p>
<h2 id="预定义宏">预定义宏</h2><p>ANSI C定义了一些宏。虽然每一个可以供您使用的编程，预定义宏不应该被直接修改。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DATE</strong></td>
<td style="text-align:center">“Jun 18 2016”</td>
<td style="text-align:center">文件被编译的时间</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td style="text-align:center">“15:47:03”</td>
<td style="text-align:center">文件被编译的时间</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td style="text-align:center">“test.c”</td>
<td style="text-align:center">进行编译的源文件名</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td style="text-align:center">“8”</td>
<td style="text-align:center">文件当前的行号</td>
</tr>
<tr>
<td><strong>STDC</strong></td>
<td style="text-align:center">“1”</td>
<td style="text-align:center">如果编译器遵循ANSI C，其值就为1，否则未定义</td>
</tr>
</tbody>
</table>
<p>例子：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"File :<span class="variable">%s</span>\n"</span>, __FILE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Date :<span class="variable">%s</span>\n"</span>, __DATE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Time :<span class="variable">%s</span>\n"</span>, __TIME_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"Line :<span class="variable">%d</span>\n"</span>, __LINE_<span class="number">_</span> );</span><br><span class="line">   <span class="keyword">printf</span>(<span class="string">"ANSI :<span class="variable">%d</span>\n"</span>, __STDC_<span class="number">_</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>File :test.c<br>Date :Jun 18 2016<br>Time :15:47:03<br>Line :8<br>ANSI :1</p>
</blockquote>
<h2 id="预处理常量_define：">预处理常量 define：</h2><p>预处理器指令从#开始，到最后第一个换行符为止。如果在结尾出现反斜杠，则定义会自动延续到下一行。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*<span class="keyword">define</span>定义一个常量<span class="title">MAX_VALUE</span>*/</span><br><span class="line"><span class="comment">#define MAX_VALUE 10</span></span><br><span class="line">/*<span class="keyword">define</span>结尾出现反斜杠，定义自动延续到下一行*/</span><br><span class="line">#<span class="title">define</span> PARAGRAPH “This is the first example\</span><br><span class="line">of <span class="keyword">define</span> "</span><br><span class="line"></span><br><span class="line"><span class="title">printf</span>(“max value is %d\n”,MAX_VALUE);</span><br><span class="line">printf(“paragraph is %s\n”,PARAGRAPH);</span><br></pre></td></tr></table></figure></p>
<p>每个define行有三部分组成。</p>
<blockquote>
<ul>
<li>第一部分为#define本身；</li>
<li>第二部分为所选择的缩略语，成为宏，宏的名字中不允许有空格，我们约定使用大写表示。<br>*第三部分为宏替换的文本，成为宏展开。如果没有替换文本，我们成为一个基本宏定义。</li>
</ul>
</blockquote>
<h2 id="宏判断：">宏判断：</h2><p>如果我们想一些段落代码，只在部分宏有定义的情况下才只用，我们这里会用到宏判断。<br>格式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line">...</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PROJECT_TEST</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">ifdef</span> PROJECT_TEST</span></span><br><span class="line">        <span class="built_in">printf</span>(“marco PROJECT_TEST is defined\n”);</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(“marco PROJECT_TEST not defined\n”);</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们在工程中定义了PROJECT_TEST这个宏，则打印第一段，否则打印第二段。</p>
<h2 id="宏函数：">宏函数：</h2><blockquote>
<p>宏函数，即用宏的方式来实现函数。<br>宏函数末尾不能带分号做结尾。<br>宏函数中的参数都需要用括号扩起来。</p>
</blockquote>
<p>例如:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define SEQUERE(a) a*a</span></span><br><span class="line"><span class="keyword">int</span> seq_value;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">seq_value = SEQUERE(a);</span><br><span class="line"><span class="keyword">printf</span>(“seq_value = <span class="variable">%d</span>\n”,seq_value);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：16</p>
<p>但是这种写法有个问题，如果我们传入的a为 a+1时，就会发生问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> seq_value;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">seq_value = SEQUERE(a+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(“seq_value = %d\n”,seq_value);</span><br></pre></td></tr></table></figure></p>
<p>输出: 9<br>输出的内容为9，而不是我们期望的25.<br>我们简化一下这个程序</p>
<p>SEQUERE(a) a<em>a<br>变为a+1</em>a+1<br>a为4，所以结果为4+1*4+1 = 9.</p>
</blockquote>
<p>为了避免这种情况，我们在宏函数中的每个参数都需要用小括号()括起来。<br>即为#define SEQUERE(a) （a）*（a）</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/15/c-and-point-thirteen-function-point/" itemprop="url">
                C与指针-第十三章-函数指针
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-15T22:08:39+08:00" content="2016-06-15">
            2016-06-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/15/c-and-point-thirteen-function-point/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/15/c-and-point-thirteen-function-point/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本文重点讲的函数指针为 回调函数和转移表。</p>
<h2 id="回调函数">回调函数</h2><h3 id="含义：">含义：</h3><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<h3 id="机制：">机制：</h3><blockquote>
<p>⑴定义一个回调函数；<br>⑵提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；<br>⑶当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</p>
</blockquote>
<h3 id="举例：">举例：</h3><p> 1.我们在路上遇到一个好多年没见到的朋友，要了朋友的手机好，跟他说我回去打给你</p>
<blockquote>
<p> 1)遇见朋友–主函数<br>  2)我打电话给朋友，通过朋友的手机号，找到朋友–(回调)</p>
</blockquote>
<p>2.寄快递的情形<br>   打电话给快递员，告诉他我的地址(理解成回调函数的地址)，快递员在有空的时候根据这个地址来找到你取件。</p>
<blockquote>
<p>1)打电话给快递员，告诉他我的地址–主函数(我的地址–回调函数地址)<br>  2)快递员处理完其他事情后，通过这个地址(回调)来找到你取件，执行完回调里面的内容。</p>
</blockquote>
<p>示例:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*回调函数*/</span></span><br><span class="line"><span class="keyword">void</span> *call_phone_number(<span class="keyword">int</span> number )</span><br><span class="line">&#123;</span><br><span class="line">      printf(<span class="string">"phone number = %d\n"</span>,number); <span class="comment">/*通过号码找到朋友*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_call</span>(<span class="params"> <span class="keyword">void</span> *call_back(<span class="keyword">int</span> number</span>))</span><br><span class="line"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> phone_number = <span class="number">12345</span>;</span><br><span class="line">      call_back(phone_number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">      start_call(call_phone_number);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="转移表">转移表</h2><p>用函数指针的形式来替换switch、if/else的方式</p>
<h3 id="示例：">示例：</h3><p>一个计算器实现<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">double add(double,double);</span><br><span class="line">double sub(double,double);</span><br><span class="line">double mul(double,double);</span><br><span class="line">double <span class="keyword">div</span>(double,double);</span><br><span class="line"></span><br><span class="line">     switch(oper)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">ADD</span>:</span><br><span class="line">               <span class="literal">result</span> = add(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">SUB</span>:</span><br><span class="line">               <span class="literal">result</span> = sub(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">MUL</span>:</span><br><span class="line">               <span class="literal">result</span> = mul(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">DIV</span>:</span><br><span class="line">               <span class="literal">result</span> = <span class="keyword">div</span>(op1mop2);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          default:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码改成转移表只需要两个步骤。<br>首先，声明并初始化一个函数指针数组。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double (*oper_func[])(double,double)=&#123;add,sub,mil,div&#125;;</span><br><span class="line"></span><br><span class="line">调用：</span><br><span class="line">result = oper_func[<span class="link_label">oper</span>](<span class="link_url">op1,op2</span>);</span><br></pre></td></tr></table></figure></p>
<p>oper从数组中选择正确的函数指针，而函数调用操作符将执行这个函数</p>
<p>=========================<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/14/c-and-point-twelve-linknode/" itemprop="url">
                C与指针-第十二章 链表
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-14T22:25:42+08:00" content="2016-06-14">
            2016-06-14
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/14/c-and-point-twelve-linknode/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/c-and-point-twelve-linknode/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<h3 id="链表细则：">链表细则：</h3><p>1)是由结构体和指针构成的。<br>2)包括两个部分一个是数据域和指针域。<br>3)链表中的结点分为两类：头结点和一般结点。头结点是没有数据域的。<br>4)基本操作有：初始化链表，增加结点和删除结点，求链表的长度等等。</p>
<p>链表主要包括：单向链表，双向链表，循环链表。</p>
<h2 id="单向链表">单向链表</h2><h3 id="含义：">含义：</h3><p>单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始；链表是使用指针进行构造的列表；又称为结点列表，因为链表是由一个个结点组装起来的；其中每个结点都有指针成员变量指向列表中的下一个结点；<br>列表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向nuLL的指针。</p>
<h3 id="用法：">用法：</h3><p>//一个链表结构体的声明<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *next;</span><br><span class="line">	int	  data;</span><br><span class="line">&#125;Node;</span></span><br></pre></td></tr></table></figure></p>
<p>单链表的指向，链表的起始位置我们成为根指针(root)，它指向链表的第一个节点。根指针不包含任何数据，它只是一个指针。<br>Node *root;<br>下一个节点的访问通过root-&gt;next来实现<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/single-link.png" alt=""></p>
<h3 id="1-初始化链表：">1.初始化链表：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitNodeList</span><span class="params">(Node **node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//链表分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span>(!*node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	(*node)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：初始化时，这里的指针为二级指针，因为我们想要获取链表的根指针，如果只传入一级指针，malloc后得到的为分配内存的首地址给node，而不能被主函数中指针变量root得到这个地址。</p>
</blockquote>
<h3 id="2-插入数据：">2.插入数据：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">按值的大小顺序进行插入，把值插入到合适的位置</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> InsertNodeList(Node **root,<span class="keyword">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">  Node *current;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  Node *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">  current = *root;</span><br><span class="line">  <span class="keyword">previous</span> = <span class="keyword">NULL</span>; <span class="comment">/*用于判断新插入的值是否在第一个节点*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*寻找正确的插入位置，按序访问链表，直到到达一个其值大于或等于新值的节点*/</span></span><br><span class="line">  <span class="keyword">while</span>(current != <span class="keyword">NULL</span> &amp;&amp; current-&gt;data &lt; data)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">previous</span> = current;</span><br><span class="line">    current  = current-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*新节点分配内存空间*/</span></span><br><span class="line">  <span class="keyword">new</span> = (Node *)malloc(sizeof(Node));</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*新节点插入链表*/</span></span><br><span class="line">  <span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">  <span class="comment">/*如果插入的值在根节点，把新节点指向根节点，否则前一个节点，指向新节点*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">previous</span> == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *root = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">previous</span>-&gt;<span class="keyword">next</span> = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-获取链表长度">3.获取链表长度</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LengthNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  <span class="keyword">previous</span>=root-&gt;<span class="keyword">next</span>;<span class="comment">/*p指向链表的第一个结点。*/</span></span><br><span class="line">  <span class="comment">/*循环链表，直到节点为空*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">previous</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">previous</span>=<span class="keyword">previous</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除节点：">4.删除节点：</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void DestroyNodeList(Node <span class="keyword">*</span>root)</span><br><span class="line">&#123;</span><br><span class="line">  Node <span class="keyword">*</span>current,<span class="keyword">*</span>next;</span><br><span class="line">  current=root;/<span class="keyword">*</span>current 指向链表的根结点<span class="keyword">*</span>/</span><br><span class="line">  /<span class="keyword">*</span>当节点指向为空，即到了链表末尾，跳出<span class="keyword">*</span>/</span><br><span class="line">  while(current)</span><br><span class="line">  &#123;</span><br><span class="line">    next = current-&gt;next;/<span class="keyword">*</span>指向当前结点的下一个结点。<span class="keyword">*</span>/</span><br><span class="line">    free(current);/<span class="keyword">*</span>释放当前结点<span class="keyword">*</span>/</span><br><span class="line">    current = next;/<span class="keyword">*</span>指向下一个结点<span class="keyword">*</span>/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调用：">5.调用：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node *root;</span><br><span class="line">	<span class="keyword">int</span> node_length = <span class="number">0</span>;</span><br><span class="line">	InitNodeList(&amp;root);  <span class="comment">/*初始化链表，得到一个跟节点*/</span></span><br><span class="line">	InsertNodeList(&amp;root,<span class="number">10</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	node_length = LengthNodeList(root); <span class="comment">/*获取链表长度*/</span></span><br><span class="line">	DestroyNodeList(root); <span class="comment">/*销毁链表*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表">双向链表</h2><h3 id="含义：-1">含义：</h3><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<h3 id="特点：">特点：</h3><blockquote>
<pre><code><span class="number">1</span>）在数据结构中具有双向指针
<span class="number">2</span>）插入、删除数据的时候需要考虑前后的方向的操作
</code></pre></blockquote>
<h3 id="用法：-1">用法：</h3><p>一个链表结构体的声明<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">	int	  data;</span><br><span class="line">&#125;<span class="constant">Node</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xn24x.com1.z0.glb.clouddn.com/mutl-link.png" alt=""></p>
<h3 id="1-初始化链表：-1">1.初始化链表：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitNodeList</span><span class="params">(Node **node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	*node=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//链表分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span>(!*node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	(*node)-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">	(*node)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.插入数据：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> InsertNodeList(register Node *root,<span class="keyword">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">  register Node *<span class="keyword">this</span>;</span><br><span class="line">  register Node *<span class="keyword">next</span>;</span><br><span class="line">  register Node *newnode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">this</span> = root;(<span class="keyword">next</span> = <span class="keyword">this</span>-&gt;<span class="keyword">next</span>)!= <span class="keyword">NULL</span>; <span class="keyword">this</span> =<span class="keyword">next</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">next</span>-&gt;data == data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">next</span>-&gt;data &gt; data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">/*新节点分配内存空间*/</span></span><br><span class="line">  newnode = (Node *)malloc(sizeof(Node));</span><br><span class="line">  <span class="keyword">if</span>(newnode == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*新节点插入链表*/</span></span><br><span class="line">  newnode-&gt;data = data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*插入新节点*/</span></span><br><span class="line">  newnode-&gt;<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="keyword">next</span> = newnode;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != root)</span><br><span class="line">  &#123;</span><br><span class="line">    newnode-&gt;prev = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    newnode-&gt;prev = <span class="keyword">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">next</span> != <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">next</span>-&gt;prev = newnode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    root-&gt;prev = newnode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-获取链表长度-1">3.获取链表长度</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LengthNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  Node *<span class="keyword">previous</span>;</span><br><span class="line">  <span class="keyword">previous</span>=root-&gt;<span class="keyword">next</span>;<span class="comment">/*p指向链表的第一个结点。*/</span></span><br><span class="line">  <span class="comment">/*循环链表，直到节点为空*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">previous</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">previous</span>=<span class="keyword">previous</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除节点：-1">4.删除节点：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DestroyNodeList(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">  Node *current,*<span class="keyword">next</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  current=root;<span class="comment">/*current 指向链表的根结点*/</span></span><br><span class="line">  <span class="comment">/*当节点指向为空，即到了链表末尾，跳出*/</span></span><br><span class="line">  <span class="keyword">while</span>(current)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">next</span> = current-&gt;<span class="keyword">next</span>;<span class="comment">/*指向当前结点的下一个结点。*/</span></span><br><span class="line">    free(current);<span class="comment">/*释放当前结点*/</span></span><br><span class="line">    current = <span class="keyword">next</span>;<span class="comment">/*指向下一个结点*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调用：-1">5.调用：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node *root;</span><br><span class="line">	<span class="keyword">int</span> node_length = <span class="number">0</span>;</span><br><span class="line">	InitNodeList(&amp;root);  <span class="comment">/*初始化链表，得到一个跟节点*/</span></span><br><span class="line">	InsertNodeList(root,<span class="number">10</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	InsertNodeList(root,<span class="number">20</span>); <span class="comment">/*向链表中插入一个数据*/</span></span><br><span class="line">	node_length = LengthNodeList(root); <span class="comment">/*获取链表长度*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,node_length);</span><br><span class="line">	DestroyNodeList(root); <span class="comment">/*销毁链表*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt="">    </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/11/c-and-point-eleven-malloc-and-free/" itemprop="url">
                C与指针-第十一章—动态内存分配
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-11T22:22:28+08:00" content="2016-06-11">
            2016-06-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/11/c-and-point-eleven-malloc-and-free/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/11/c-and-point-eleven-malloc-and-free/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>我们使用数组时，它是存储于内存中连续的位置上，它所需要的内存在编译时就被分配，使用起来比较方便，但是也存在几个缺点。</p>
<h3 id="数组的缺点:">数组的缺点:</h3><p>1)假如一个数组无限大，而我们只需要很少的几个字节，这就会造成内存浪费，增加了内存的开销。<br>2)我们我们访问超过数组下标的内容时，造成数组越界，有可能产生一个异常值，从而导致失败。</p>
<p>针对这两点，动态内存分配的处理就相对比较适用。动态内存分配中使用的几个关键字<br>malloc和free，这两个是成对出现的，malloc用来申请内存空间，free用来释放内存。</p>
<h2 id="malloc和free">malloc和free</h2><p>malloc从内存池中提取一块合适的内存，并向该程序返回一个指向这块内存的指针。这块内存没有初始化。<br>当内存不再使用时，调用free把这块内存归还给内存池。</p>
<h3 id="原型：">原型：</h3><blockquote>
<p>void <em>malloc(size_t size);<br>void free(void </em>pointer);</p>
</blockquote>
<p>malloc的参数是需要分配的内存字节数。<br>malloc分配的是一块连续的内存。如果请求分配的是100个字节，那么实际分配的就是100个连续的字节，不会分开于两块或多块不同的内存。<br>如果内存池为空，或者申请内存不成功，malloc就会返回一个NULL指针。如果需要对分配的内存进行检查，可以通过与NULL指针进行比较来判断内存是否分配成功。</p>
<p>free的参数必须是从malloc、calloc或relloc返回的值，或者是NULL。传递NULL指针不会产生任何效果。</p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">...</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">100</span>);     <span class="comment">//申请内存空间</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0x0</span>,<span class="number">100</span>);  <span class="comment">//清空内存</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>)  <span class="comment">//判断内存是否申请成功</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(“out of memory!\n”);</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a); <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure></p>
<h2 id="calloc和relloc">calloc和relloc</h2><h3 id="原型：-1">原型：</h3><blockquote>
<p>void <em>calloc(size_t num_elements, size_t element_size);<br>void realloc(void </em>ptr,size_t new_size);</p>
</blockquote>
<p>calloc用于内存的申请。<br>calloc与malloc之间的主要区别是calloc在返回指向内存的指针之前把它初始化为0。但是如果你的程序知识想把一些值存储到数组中，那么这个初始化过程纯属浪费时间。</p>
<p>relloc函数用于修改一个原先已经分配的内存块大小。使用这个函数，你可以使一块内存扩大或缩小。如果它用于扩大一个内存块，那么这块内存原先的内容依然保留，新增加的内存添加到原先内存块的后面，新的内存并未以任何方式进行初始化。该内存块尾部的部分内存便被拿掉，剩余部分内存的原先内容依然被保留。</p>
<p>如果realloc函数的第1个参数是NULL，那么它的行为就和malloc一样。</p>
<h2 id="内存泄漏：">内存泄漏：</h2><p>当动态分配的内存不再需要使用时，它应该被释放。如果内存不释放，将会引起内存泄漏。内存泄漏可以一点点的榨干可用内存，从而导致程序崩溃。</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/10/c-and-point-ten-struct/" itemprop="url">
                C与指针-第十章-结构体\联合union
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-10T22:49:51+08:00" content="2016-06-10">
            2016-06-10
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/10/c-and-point-ten-struct/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/10/c-and-point-ten-struct/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。</p>
<h2 id="含义：">含义：</h2><p>结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。</p>
<h2 id="定义与声明：">定义与声明：</h2><p>结构体的定义如下所示，struct为结构体关键字，tag为结构体的标志，member-list为结构体成员列表，其必须列出其所有成员；variable-list为此结构体声明的变量。</p>
<blockquote>
<p>struct tag {<br>member-list<br>} variable-list ;</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;s2;</span><br><span class="line">注：s1和s2被编译器当做两种截然不同的类型，即使他们成员列表相同。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">用标签来创建变量：</span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span> x;</span><br><span class="line"><span class="keyword">struct</span> SI<span class="built_in">MPLE</span> y[<span class="number">20</span>];</span><br><span class="line">这里x和y是两个完全相同的类型，因为他们用标签来进行定义</span><br></pre></td></tr></table></figure>
<h2 id="typedef：">typedef：</h2><p>声明结构体时可以使用的另一种良好技巧是用typedef创建一种新的类型。</p>
<blockquote>
<p>typedef struct{<br>     int a;<br>     char b;<br>     double c;<br>}s3;</p>
</blockquote>
<p>这个技巧和标签的效果几乎完全相同，区别在于s3现在是个类型名而不是个结构标签。以后的声明如下：</p>
<blockquote>
<p>s3 x;<br>s3 y[20];</p>
</blockquote>
<h2 id="结构成员：">结构成员：</h2><p>结构体的成员可以是标量、数组、指针甚至是其他结构体。</p>
<blockquote>
<p>typedef struct{<br>     int a;<br>     char b;<br>     double c:<br>     s3 d;<br>     s3 e[10];<br>}s4;</p>
</blockquote>
<h3 id="1)直接访问">1)直接访问</h3><p>结构体成员通过’.’操作符来访问的。<br>例：<br>s4 comp;</p>
<p>访问成员a， comp.a;<br>访问成员d中的a， comp.d.a;<br>访问成员e中第5个元素的成员a，comp.e[4].a;</p>
<h3 id="2)间接访问">2)间接访问</h3><p>如果拥有一个指向结构体的指针，那么我们访问结构体成员需要用’-&gt;’操作符来访问。<br>s4 *comp;</p>
<p>访问成员a， comp-&gt;a;<br>访问成员d中的a， comp-&gt;d.a;<br>访问成员e中第5个元素的成员a，comp-&gt;e[4].a;</p>
<h2 id="联合：">联合：</h2><h3 id="含义：-1">含义：</h3><p>“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>
<blockquote>
<p>联合使用关键字union来定义。</p>
</blockquote>
<h3 id="声明：">声明：</h3><p>联合声明跟结构体类似。<br>union {<br>     数据成员；<br>}变量；</p>
<blockquote>
<p>union{<br>      int a;<br>     float b;<br>}message；</p>
</blockquote>
<p>在一个32位的机器上，变量message只占用内存中最大的变量类型的大小，这里int跟float占用内存相同，因此变量message这里只占用内存中一个32位的字。<br>如果a被访问，这个字就作为int型访问；<br>如果b被访问，这个字就作为float型访问。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>.b = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">message</span>.a = <span class="number">10</span>;</span><br><span class="line">printf(“%d\n”,<span class="keyword">message</span>.a);</span><br><span class="line">printf(“%f\n”,<span class="keyword">message</span>.b);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>由于最后一个访问的是a，因此a打印的值为10，b的值为0.000000；反之相同</p>
</blockquote>
<h3 id="union和结构体：">union和结构体：</h3><p>通常我们把union和struct结合起来使用，这样更加方便我们的程序开发。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     int age;</span><br><span class="line">     int height;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     int year;</span><br><span class="line">     char class_name[<span class="number">10</span>];</span><br><span class="line">     <span class="class"><span class="keyword">enum</span> &#123;<span class="title">class1</span>,<span class="title">class2</span>&#125; <span class="title">type</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span>  <span class="title">first_student</span>;</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span>  <span class="title">second_student</span>;</span></span><br><span class="line">     &#125;data;</span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    int y;</span><br><span class="line">    int z;</span><br><span class="line">   <span class="regexp">/*msg相关变量赋值*/</span></span><br><span class="line">    msg.data.first_student.age = <span class="number">10</span>;</span><br><span class="line">    msg.data.first_student.height = <span class="number">170</span>;</span><br><span class="line">    msg.<span class="keyword">type</span> = class1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msg.<span class="keyword">type</span> == class1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">/*union一次只能访问一个成员*/</span></span><br><span class="line">         y = msg.data.first_student.age;</span><br><span class="line">         z = msg.data.first_student.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         y = msg.data.second_student.age;</span><br><span class="line">         z = msg.data.second_student.height;</span><br><span class="line">    &#125;</span><br><span class="line">      printf(<span class="string">"%d\n"</span>,y);  <span class="regexp">//</span>打印<span class="number">10</span></span><br><span class="line">      printf(<span class="string">"%d\n"</span>,z);  <span class="regexp">//</span>打印<span class="number">170</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结：">总结：</h2><p>1.结构体中，不同类型的值可以存储在一起，成员可以是标量、数组、指针或结构体<br>2.不同的二结构体声明即使它们的成员列表相同也被认为是不同的类型，typedef可以用于解决此问题<br>3.联合的所有成员都存储于同一个内存位置，通过访问不同类型的联合成员，内存中相同的位组合可以被解释为不同的东西。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/09/c-and-point-nine-char/" itemprop="url">
                C与指针-第九章-字符、字符串处理API
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-09T23:08:16+08:00" content="2016-06-09">
            2016-06-09
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/09/c-and-point-nine-char/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/09/c-and-point-nine-char/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>字符串是一种重要的数据类型，但是C语言并没有显式的字符串数据类型，因此字符串以字符串常量的形式出现或存储于字符数组中。字符串常量很适用于那些程序不会对它们进行修改的字符串。所有其他字符串都必须存储于字符数组或动态分配的内存中。本次主要描述处理字符串和字符的库函数。</p>
<p>字符串就是一串零个或多个字符，并且以一个位模式为全0的NUL字节结尾。因此，字符串所包含的字符内部不能出现NUL字节。<br>     字符、字符串处理需要引入string.h这个头文件</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span>
</code></pre><h2 id="1-字符串长度">1.字符串长度</h2><p>API: strlen<br>原型：size_t strlen(char const *string)<br>返回值:string字符串的长度，不包括结束符\0<br>作用：strlen返回一个类型为sizt_t的值，属于一个无符号整数类型。即为传入字符串的长度<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br></pre></td></tr></table></figure></p>
<p>这里i打印值为5，即为字符串hello的长度，不包含结束符。</p>
<p>尝试模仿strlen的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strlen(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*<span class="built_in">string</span>++ != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-复制字符串">2.复制字符串</h2><h3 id="1)不受长度限制">1)不受长度限制</h3><p>API：strcpy<br>原型：char <em>strcpy(char </em>dst,char const *src)<br>返回值：返回指向dst字符串的指针<br>作用：这个函数把参数src字符串复制到dst参数。如果参数src和dst在内存中出现重叠，其结果是未定义的。dst必须是一个字符数组或者是一个指向动态分配内存的数组的指针。<br>     src赋值给dst，dst以前的内容将会被覆盖丢失.如果src的长度超过了dst数组的长度，执行时会crash<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,<span class="string">"message"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line"> 输出内容为 message</span><br></pre></td></tr></table></figure></p>
<p>模仿strcpy的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制">2)长度受限制</h3><p>API:strncpy<br>原型：char <em>strncpy(char </em>dst, char const *src, size_t len);<br>返回值：返回指向dst字符串的指针<br>作用：把src字符串的字符复制到dst数组中。它总是正好向dst写入len个字符。如果strlen(src)的值小于len，dst数组会用额外的NUL字节填充到len长度。如果strlne(src)的值大于或等于len，那么只有len 个字符被复制到dst中。<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">30</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(buf,<span class="string">"A message"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">//输出A mes world，长度为5，其余的不拷贝</span></span><br><span class="line"><span class="built_in">strncpy</span>(buf,<span class="string">"A message"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">//输出A message</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strncpy的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strncpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src ,<span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len &amp;&amp; src[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-连接字符串">3.连接字符串</h2><h3 id="1)不受长度限制-1">1)不受长度限制</h3><p>API: strcat<br>原型：char <em>strcat(char </em>dst, const char *src);<br>返回：返回指向dst字符串的指针<br>作用：把src的字符串添加(连接)到dst字符串后面。这里要求dst原先已经包含了一个字符串(可以为空字符串)。它找到这个字符串的末尾。并把src字符串的一份拷贝添加到这个位置。如果src和dst的位置发生重叠，其结果是未定义的。<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = “hello”;</span><br><span class="line"><span class="built_in">strcat</span>(buf,”world”);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出helloworld</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strcat的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_stcat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制-1">2)长度受限制</h3><p>API: strncat<br>原型：char <em>strncat(char </em>dst, const char *src,size_t len);<br>返回值：指向dst的指针<br>作用：从src中复制长度为len个字符到dst中<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = “hello”;</span><br><span class="line"><span class="built_in">strncat</span>(buf,”world”,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出hellowo</span></span><br><span class="line"><span class="built_in">strncat</span>(buf,”world”,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,buf); <span class="comment">//输出helloworld，超过部分遇到\0结束符，不再进行连接</span></span><br></pre></td></tr></table></figure></p>
<p>模拟strncat：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_stncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> * src,size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) || (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len &amp;&amp; (*dst++ = *src++) != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-字符串比较">4.字符串比较</h2><h3 id="1)不受长度限制-2">1)不受长度限制</h3><p>API: strcmp<br>原型：int strcmp(const char <em>s1, const char </em>s2)<br>返回值：0表示两个字符串相同，其余表示两个字符串不同<br>作用：对两个字符串s1\s2逐个字符进行比较，直到发现不匹配为止<br>用法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">ret</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">ret</span> = strcmp(buf,<span class="string">"hello”);</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">ret</span>);//输出<span class="number">0</span>，两个字符串相同</span><br><span class="line"><span class="keyword">ret</span> = strcmp(buf,”hello world<span class="string">");</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">ret</span>);//输出-<span class="number">32</span>，两个字符串不同</span><br></pre></td></tr></table></figure></p>
<p>模仿strcmp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strcmp(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">NULL</span>) || (s2 == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2)长度受限制-2">2)长度受限制</h3><p>API: strncmp<br>原型：int strcmp(const char <em>s1, const char </em>s2,size_t len)<br>返回值：0表示两个字符串相同，其余表示两个字符串不同<br>作用：对两个字符串s1\s2逐个字符进行比较，直到发现不匹配为止<br>用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = <span class="built_in">strncmp</span>(buf,<span class="string">"hello"</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret); <span class="comment">//输出0，表示hello中前两个字符he跟hello中前两个相同</span></span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">strncmp</span>(buf,<span class="string">"hello world"</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret); <span class="comment">//输出-32，表示不相等，即hello world前8个字符，与hello不相等</span></span><br></pre></td></tr></table></figure></p>
<p>模仿strncmp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> my_strncmp(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> * s2,<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1 == <span class="literal">NULL</span>) || (s2 == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-字符串查找">5.字符串查找</h2><p>原型：char strstr(char <em>s1, char </em>s2)<br>返回值：NULL，或者指向查找到的起始位置的指针<br>作用：这个函数在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针。如果s2并没有完整地出现在s1的任何地方，函数将返回一个NULL指针，如果s2是一个空字符串，函数就返回是</p>
<p>用法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line">char *<span class="keyword">last</span> = NULL;</span><br><span class="line"><span class="keyword">last</span> = strstr(buf,<span class="string">"he”);</span><br><span class="line"></span><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="keyword">last</span>); //打印hello</span><br><span class="line"><span class="keyword">last</span> = strstr(buf,<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="keyword">last</span>); //打印null</span><br></pre></td></tr></table></figure></p>
<p>模拟strstr写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">my_strstr</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> * s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*s1 == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*s1 != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s2[i] == <span class="string">'\0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> s1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s2[i] != s1[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        s1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-内存操作：">6.内存操作：</h2><p>主要有memcpy、memmove、memcmp、memchr、memset几个函数</p>
<h3 id="原型：">原型：</h3><blockquote>
<p>void <em>memcpy(void </em>dst,void const <em>src,size_t length);<br>void </em>memmove(void <em>dst,void const </em>src,size_t length);<br>void <em>memcmp(void const </em>s1,void const <em>s2,size_t length);<br>void </em>memchr(void <em>s1,void const </em>s2,size_t length);<br>void <em>memset(void </em>dst,int ch,size_t length);</p>
</blockquote>
<h3 id="用法:">用法:</h3><h3 id="memcpy">memcpy</h3><p>从src的起始位置赋值length个字节到dst的内存起始位置，可以复制任何类型。如果src和dst出现重叠，其结果是未知的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dst[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> src[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(dst,src,<span class="built_in">strlen</span>(src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,dst );</span><br></pre></td></tr></table></figure></p>
<p>模拟memcpy：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_memcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> * src,size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dst == <span class="literal">NULL</span>) &amp;&amp; (src == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len-- &gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="memmove：">memmove：</h3><p>memmove用于从src拷贝count个字符到dest，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中。但复制后src内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。<br>用法：<br>char s[]=”Golden Global View”;<br>memmove(s,s+7,strlen(s)+1-7);<br>printf(“%s”,s);<br>程序输出结果：Global View<br>*注意：这里的拷贝长度strlen(s)+1-7表示把字符串结尾的’\0’也拷贝进来。</p>
<h3 id="memcmp">memcmp</h3><p>memcmp是比较内存区域buf1和buf2的前count个字节。该函数是按字节比较的。<br>返回值：<br>当s1<s2时，返回值<0 当s1="=s2时，返回值=0">s2时，返回值&gt;0</s2时，返回值<0></p>
<blockquote>
<p>如:char <em>s1=”abc”;<br>char </em>s2=”acd”;<br>int r=memcmp(s1,s2,3);<br>就是比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了。所以r=-1</p>
</blockquote>
<h3 id="memchr:">memchr:</h3><p>从buf所指内存区域的前count个字节查找字符ch。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s=<span class="string">"Hello, Programmers!"</span>;</span><br><span class="line"><span class="keyword">void</span> *p;<span class="comment">//因为memchr(,,);return void*p;</span></span><br><span class="line">p=<span class="built_in">memchr</span>(s,<span class="string">'P'</span>,<span class="built_in">strlen</span>(s));</span><br><span class="line"><span class="comment">//p=(char *)memchr(s,'P',sizeof(s)); //s是一个指向char的指针，而任何指针都是个一个4字节的数，在这里应//该是要说明搜索整个字符串的长度，所以应该用strlen(s)</span></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s"</span>,p);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Not Found!"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="memst">memst</h3><p>将s所指向的某一块内存中的前n个 字节的内容全部设置为ch指定的ASCII值<br>通常用来进行内存初始化作用<br>例如：<br>char dst[20];<br>memset(dst,0x0,sizeof(dst)); //把dst指向的大小为20的内存区域值都设置为0.</p>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/07/c-and-point-eight/" itemprop="url">
                C与指针-第八章-数组
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-07T22:22:28+08:00" content="2016-06-07">
            2016-06-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/07/c-and-point-eight/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/07/c-and-point-eight/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>所谓数组，就是相同数据类型的元素按一定顺序排列的集合，就是把有限个类型相同的变量用一个名字命名，然后用编号区分他们的变量的集合，这个名字称为数组名，编号称为下标。</p>
<p>特点：只能存放一种类型的数据，如全部是int型或者全部是char型，数组里的数据成为元素。</p>
<h2 id="一维数组：">一维数组：</h2><h3 id="格式：">格式：</h3><p>类型 数组名[元素个数-常量表达式]<br>（1）数组名的命名方法与变量名相同，遵循标识符命名规则;<br>（2）数组是用方括号括起来的常量表达式，不能用圆括号;<br>（3）常量表达式表示数组元素的个数，即数组的长度，数组的下标从0开始，下标的最大值为:<br>常量表达式-1;<br>（4）常量表达式中可以包括常量和符号常量，不能包括变量。<br>可以用赋值语句或输入语句使数组中的元素得到值，但要占用运行时间。可以使数组在运行之前初始化，即在编译阶段使之得到初值。</p>
<h3 id="初始化：">初始化：</h3><p>int buf[5] = {1,2,3,4,5};<br>这里把buf数组中的5个元素初始化为1,2,3,4,5</p>
<h3 id="下标：">下标：</h3><p>这里变量buf称为数组，因为它是一些值的集合，下标和数组名一起使用，用于标示该集合中的某个特定的值。例如buf[0]表示数组buf的第一个元素的值，这里值为1. buf[4]标示数组buf第5个值，这里值为5.<br>buf[0]  //对应的值为1<br>buf[4] //对应的值为5<br>数组的下标从0开始计数</p>
<h2 id="多维数组：">多维数组：</h2><p>某个数组的维数不止1个，我们称这个数组为多维数组</p>
<h3 id="格式：-1">格式：</h3><p>数组［下标］［下标］</p>
<p>在引用二维数组时，必须是单个元素，不能是整个数组名。下标可以是一个表达式，但不能是变量。如果下标是一个表达式，注意表达式的值不能超出数组定义的上、下限。</p>
<p>int num[3][5];<br>创建了一个包含15个元素的矩阵。我们一般把这个理解为3行5列，当然也可以理解为5行3列，为了我们方便记忆，我们看做为3行10列。</p>
<p>(1) 多维数组初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num[<span class="number">3</span>][<span class="number">5</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;,&#123;<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span>，<span class="number">10</span>&#125;,&#123;<span class="number">11</span>，<span class="number">12</span>，<span class="number">13</span>，<span class="number">14</span>，<span class="number">15</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上赋值把第一个花括号内的数据赋给第一行元素，第二个花括号内数据赋给第二元素，以此类推，即按行赋值</p>
<p>(2) 可以将所有的数据写在一个花括号内，按数组排列的顺序对各元素赋值。</p>
<p>(3)可以对数组的部分元素赋初值。如:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int a[<span class="link_label">3</span>][<span class="link_reference">5</span>]  = &#123;&#123;1&#125;,&#123;6&#125;，&#123;11&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上赋值的结果是:数组第一列的元素分别赋了初值1，6，11，其余元素的值都是0。<br>(4)如果对二维数组的全部元素都赋初值，则定义数组时对第一维的长度可以不指定，但第二维的长度不能省。</p>
<h2 id="指针数组_&amp;数组指针：">指针数组 &amp;数组指针：</h2><p>　　指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。<br>　　数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。</p>
<p>例：</p>
<h3 id="指针数组：">指针数组：</h3><blockquote>
<p>int <em>num1[10];<br>“[]”的优先级比“</em>”要高,num1先与“[]”结合，构成一个数组的定义，数组名为num1.int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。</p>
</blockquote>
<h3 id="数组指针：">数组指针：</h3><blockquote>
<p>int (<em>num2)[10];<br>在这里“()”的优先级比“[]”高，“</em>”号和num2 构成一个指针的定义，指针变量名为num2,int 修饰的是数组的内容，即数组的每个元素。</p>
</blockquote>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/05/c-and-pint-seven-function/" itemprop="url">
                C与指针-第七章-函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-05T22:55:12+08:00" content="2016-06-05">
            2016-06-05
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/05/c-and-pint-seven-function/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/05/c-and-pint-seven-function/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>函数是指一段在一起的、可以做某一件事的程序，也叫子程序、方法。</p>
<h2 id="定义：">定义：</h2><blockquote>
<p>返回类型  函数名字(形式参数)<br>{<br>     代码块<br>}</p>
</blockquote>
<p>形式参数列表包括变量名和它们的类型声明。<br>代码块包含了局部变量的声明和相关执行语句。<br>compare.c中<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int max(int <span class="keyword">value</span><span class="number">_</span>left, int <span class="keyword">value</span><span class="number">_</span>right)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">_</span>left &gt; <span class="keyword">value</span><span class="number">_</span>right)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span><span class="number">_</span>left;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span><span class="number">_</span>right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数的类型声明为void，没有返回值；否则，需要相应类型的返回值。</p>
<h2 id="声明：">声明：</h2><p>当我们在一个源文件中定义的函数想被其他源文件使用的话，我们需要在头文件中声明这个函数，想调用这个函数的源文件中，include这个头文件即可。<br>.h文件中按如下方式进行声明。<br>返回类型  函数名字(形式参数)；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internel.h中</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> value_left ,<span class="keyword">int</span> value_right)</span></span>;</span><br><span class="line"></span><br><span class="line">在 main.c中使用</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> max_value;</span><br><span class="line">   max_value(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">   <span class="built_in">printf</span>(“max value is %d\n”,max_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数形参：">函数形参：</h2><p>C函数的所有参数均以“传值调用”方式进行传递。但是当我们传进来的参数为一个数组时，并在函数㕜使用下表引用该数组的参数，那么实际上函数对该数据的修改是调用程序中数组的元素，这个行为被称为“传址调用”。</p>
<p>下面这个数组，length为传值调用，array为传址调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (length &gt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">/*把数组的元组清零*/</span></span><br><span class="line">          <span class="built_in">array</span>[lengh] = <span class="number">0</span>;</span><br><span class="line">          length—;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="递归与迭代：">递归与迭代：</h2><h3 id="递归算法：">递归算法：</h3><p>直接或间接调用自身的函数。<br>把操作的内容放入栈，等函数递归完成后，出栈打印<br>下面这个简单的例子来说明递归调用方式。<br>程序作用：输入一个值，循环打印它的除以10 后剩余的值。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (input &gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span>(<span class="title">input</span></span>/<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(<span class="string">"%d\n"</span>,input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span>(1234);</span><br><span class="line">  <span class="title">return</span></span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>0<br>1<br>12<br>123<br>1234</p>
</blockquote>
<p>这里递归的操作依次为，先把第一个input放入栈，此时为1234；当再次调用时得到input的值，input为123，把123放入栈，一直大牌最后input的值为0，结束递归，打印时，先从栈顶取出数据，栈顶数据为0，栈底数据为1234，打印上面输出的结果<br>数据操作如下图所示：<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/c_function.png" alt=""></p>
<h3 id="迭代算法：">迭代算法：</h3><p>迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p>
<p>迭代算法是用计算机解决问题的一种基本方法。它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。</p>
<p>对于上面递归的算法，我们换成迭代来实现：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> input)</span><br><span class="line">&#123;</span><br><span class="line">   int ret;</span><br><span class="line">   <span class="keyword">while</span>(input &gt;<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     ret = input;</span><br><span class="line">     printf(<span class="string">"%d\n"</span>,ret);</span><br><span class="line">     input = input/<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结：">总结：</h3><p>递归的使用可以使代码更加简洁清晰，可读性更好，但由于递归需要系统堆栈，所以空间消耗比非递归代码要大很多。<br>理论上，递归与迭代在时间复杂度方面是等价的，但实际上递归的效率确实比迭代低。<br>一般情况下，能不用递归我们就尽量不使用递归，我们使用递归的先决条件是，当且仅当一个存在预期的收敛时，我们才使用递归算法，否则我们还是用迭代。</p>
<h2 id="可变参数：">可变参数：</h2><p>我们之前将的函数传进来的参数个数都是固定的，那么我们有没有办法，函数的参数有多个，但是我们只调用其中一部分呢，C的可变参数实现了这一功能。<br>     我们看下面这个例子，msg函数有多个参数，但是我们只调用其中一个，这种方式我们可以用在log打印上，可以打印不同类型的log，以及多个参数列表实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y…)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     msg(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C的可变参数使用，需要用到下面一些函数：<br>void va_start( va_list arg_ptr, prev_param );<br>type va_arg( va_list arg_ptr, type );<br>void va_end( va_list arg_ptr );</p>
<p>va_list:用来保存宏va_start、va_arg和va_end所需信息的一种类型。为了访问变长参数列表中的参数，必须声明va_list类型的一个对象       定义： typedef char *  va_list;</p>
<p>va_start:访问变长参数列表中的参数之前使用的宏，它初始化用va_list声明的对象，初始化结果供宏va_arg和 va_end使用；</p>
<p>va_arg: 展开成一个表达式的宏，该表达式具有变长参数列表中下一个参数的值和类型。每次调用va_arg都会修改用va_list声明的对象，从而使该对象指向参数列表中的下一个参数；</p>
<p>va_end:该宏使程序能够从变长参数列表用宏va_start引用的函数中正常返回。<br>va在这里是variable-argument(可变参数)的意思.</p>
<p>这些宏定义在stdarg.h中,所以用到可变参数的程序应该包含这个头文件.下面我们写一个简单的可变参数的函数,改函数至少有一个整数参数,第二个参数也是整数,是可选的.函数只是打印这两个参数的值.</p>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_print</span><span class="params">(<span class="keyword">char</span> *msg,...)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    va_list arg_ptr; <span class="comment">/* 定义保存函数参数的结构 */</span></span><br><span class="line">    <span class="keyword">int</span> ipara =<span class="number">0</span>;      <span class="comment">/* 定义参数个数 */</span></span><br><span class="line">    <span class="keyword">char</span> *para = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>  flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arg_ptr指向传入的第一个可选参数，msg是最后一个确定的参数 */</span></span><br><span class="line">    va_start(arg_ptr, msg);</span><br><span class="line">    <span class="keyword">while</span>(*msg)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = *msg++;</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="string">'%'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(flag); <span class="comment">/*  如果字符不包括%号，把字符输出到终端上 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = *msg++; <span class="comment">/*  如果字符是%号，指针后移一位，判断对应格式 */</span></span><br><span class="line">        <span class="keyword">switch</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>: <span class="comment">/*  检索到%s，进行字符串的打印 */</span></span><br><span class="line">                para = va_arg(arg_ptr, <span class="keyword">char</span> *); <span class="comment">/*  取出当前的参数，类型为char *. */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>,para);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                ipara = va_arg(arg_ptr, <span class="keyword">int</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, ipara);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(arg_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    msg_print(<span class="string">"The first print %d\n"</span>,<span class="number">100</span>);</span><br><span class="line">    msg_print(<span class="string">"The second print %s,%d\n"</span>,<span class="string">"hello"</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：<br>he first print 100<br>The second print hello,200</p>
</blockquote>
<p>#=========================#<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/04/c-and-point-point/" itemprop="url">
                C与指针-第六章-指针
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-04T23:12:18+08:00" content="2016-06-04">
            2016-06-04
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/C与指针/" itemprop="url" rel="index">
                  <span itemprop="name">C与指针</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/04/c-and-point-point/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/04/c-and-point-point/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="指针">指针</h2><h3 id="含义：">含义：</h3><p>在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p>
<p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址</p>
<blockquote>
<p>&amp;操作符：取变量的地址<br>*操作符：对指针做解引用操作</p>
</blockquote>
<h3 id="地址&amp;内存：">地址&amp;内存：</h3><p>计算机的内存由数以亿万技的位(bit)组成，每个位可以容纳0和1.</p>
<p>由于位的标示范围太有限，计算机中为了可以存储较大范围的值，通常把许多个位合成一组作为一个单位。在现代大多数的机器中，常用的是用8个位来组成一个单位，这里成为字节(byte)。1个字节可以存储无符号值0~255，或有符号值-128~127。</p>
<p> 其实字节标示的大小也比较有限，为了继续扩大存储的范围，我们把更多个字节组合在一起，作为一个更大的单位。</p>
<p> 例如：</p>
<blockquote>
<p>int   –4个字节   ，32位为4个字节<br>  float –4个字节<br>  long –4个字节<br>  long long —8个字节</p>
</blockquote>
<p>需要注意的：<br>1)内存中的每个位置由一个独一无二的地址标识<br>2)内存中的每个位置都包含一个值<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/c_point.png" alt=""></p>
<blockquote>
<p>int a =112,b = -1;<br>  float c = 3.14;<br>  int <em>d = &a;<br>  float </em>e = &c;</p>
<p>a,b,c,d,e分别表示什么<br>a是112，b为-1，c为3.14<br>d是指向int型的指针，这里指向a的地址，a的地址是100，所以d的值为100<br>e为指向float型的指针，这里指向c的地址，c的地址为108，所以e的值为108</p>
</blockquote>
<h3 id="间接访问操作符：">间接访问操作符：</h3><h4 id="含义：-1">含义：</h4><p>通过一个指针访问它所指向的地址的过程称为间接访问或解引用指针。</p>
<h4 id="操作符：对应的操作符为*">操作符：对应的操作符为*</h4><p>例如：<br>我们上面一节中的d为100，<em>d即为间接访问，</em>d的值为int类型，d的值为100，<em>d标示访问内存位置100并查看哪里的值，因此</em>d的右值为112.</p>
<p>未初始化和非法的指针：<br> 下面这个代码有没有问题：</p>
<blockquote>
<p> int <em>a;
 </em>a = 10;</p>
</blockquote>
<p>语句描述：这个语句声明创建了一个名叫a的指针变量。<br> *a = 10表示把12 存储到a所指向的内存位置。</p>
<p>正常编译这个语句没有问题，但是在正常使用的过程中，会存在一些隐患。这里的a没有做初始化，那么a指向哪个地址我们不清楚，所以这个10存储到哪个内存区域，其实我们也不能清楚的知道。</p>
<pre><code><span class="blockquote">&gt; 如果指针变量是静态的，它会自动初始化为0</span>
<span class="blockquote">&gt; 如果指针变量是自动的，那它根本不会被初始化。</span>
</code></pre><p>所以当，赋值操作进行时，如果a的初值是个非法地址，这个语句将会出错，程序终止；如果a的初值是个合法地址，那么地址上的值被修改，但是我们不确定那个地址是否是我们想要修改的地方。<br>     所以，在对指针进行间接访问之前，要确保它已经初始化。</p>
<h3 id="空指针：">空指针：</h3><p>含义：表示不指向任何东西(地址或内容)<br>用法：要使一个指针变量位NULL，就需要给它赋一个零值。<br>         想要测试一个指针是否为空，我们需要拿它与零值进行比较。这个零值由源代码约定得出。<br>     指针与零值比较来判断是否为空，我们最好用!这个符号来表示，这样可以排除隐士类型转换，也增强了可读性<br>例如：</p>
<blockquote>
<p>int a = 10;<br>int *b = &a;<br>if (!b)<br>{<br>  printf(“point p is not null\n”);<br>}</p>
</blockquote>
<h3 id="指针的指针:">指针的指针:</h3><p>我们用**来进行表示指针的指针，例如：</p>
<blockquote>
<p>int a = 10;<br>int <em>b = &a;<br>int *</em>c = &b;</p>
</blockquote>
<p>假设a的地址为101<br>那么b = 101, <em>b = 10;<br>**c相当于</em>(<em>c),我们必须从里向外逐成求值。</em>c访问c所指向的位置，即为变量b，为101，<em>(</em>c)这个间接访问操作，即访问c所指向位置的地址，这里就死&amp;b，就是变量a，值为10.</p>
<h3 id="指针运算:">指针运算:</h3><p> 指针运算包括 算数运算和关系运算：</p>
<h4 id="运算符：+_,-,++,—">运算符：+ ,-,++,—</h4><p>   这种形式只能用于指向数组中某个元素的指针，结果类型也是指针。<br>   指针的算数运算都需要操作一段连续的内存空间，例如数组</p>
<h4 id="指针运算：+，++">指针运算：+，++</h4><blockquote>
<p> int   value[5]<br>   int   *p;<br>  (1) p = &amp;value[0];//p指向value数组的第一个元素<br>      P += 2;  //p向后偏移两个int长度的位置，即指向了value数组的第三个元素</p>
<p>(2) for (p = &amp;value[0]; p&lt; &amp;value[5];)<br>     {<br>          <em>p++ =0;   //这边先进行</em>p = 0的操作，即把value[0]赋初值为0，再指针后移一位，循环初始化value这个数组<br>     }</p>
</blockquote>
<p>   当p这个指针指向的地址大于value[5]的地址，循环结束，p &lt;&amp;value[5],这里经过了5此循环后，p就指向了value数组最后一个数组外面的那个地址，指针可能可以合法的获取这个值，但对它执行简介访问操作可能意外的原先存储于这个位置的变量，我们一般不知道这个变量是什么，因此，这种情况下，一般不允许对指向这个位置的指针进行间接操作，即*p = 10这种操作</p>
<h4 id="指针运算:_-，–">指针运算: -，–</h4><p>  指针相减运算，只适用于数组的操作，即两个指针都指向同一个数组中的元素时，才允许一个指针减去另一个指针。</p>
<blockquote>
<p>int   value[5]<br>   int   <em>p;<br>  (1) p = &amp;value[4];//p指向value数组的第一个元素<br>      P -= 2;  //p向前偏移两个int长度的位置，即指向了value数组的第三个元素<br> (2) for (p = &amp;value[4]; p&gt;= &amp;value[0]; p–)<br>     {
          </em>p =0;   //这边先进行*p = 0的操作，即把value[4]赋初值为0，再指针减减，向前移动一位，循环初始化value这个数组<br>     }</p>
</blockquote>
<p>当p这个指针指向的地址小于value[0]的地址，循环结束，p &gt; = &amp;value[0],经过5次循环后，p指针指向了数组第一个元素之前,这里我们同样不能再对p这个指针进行间接操作。</p>
<h3 id="总结：">总结：</h3><p>1)未初始化的指针变量，不能进行解引用操作<br>2)初始化为NULL的指针，不能进行解引用操作<br>3)指针进行加减法操作后，指向了数组外面的内存地址后，不能对它们进行间接操作<br>4)指针的减法操作只能针对同一个数组的元素进行</p>
<p>=========================<br>微信公众号：天歌的编程小结<br>公众号ID：vipgty<br><img src="http://7xn24x.com1.z0.glb.clouddn.com/tiangermy-wechart.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xn24x.com1.z0.glb.clouddn.com/headphoto.png" alt="Tianger Ge" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Tianger Ge</p>
        </div>
        <p class="site-description motion-element" itemprop="description">3G/LTE protocol | C</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">41</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tianger Ge</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tianger"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
